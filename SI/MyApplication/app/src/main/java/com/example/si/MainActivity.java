package com.example.si;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.core.content.FileProvider;
import androidx.loader.content.CursorLoader;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.pm.ConfigurationInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.graphics.Bitmap;

import android.graphics.BitmapFactory;
import android.graphics.Color;
//import android.media.ExifInterface;
import android.opengl.GLES30;
import android.opengl.GLSurfaceView;
import android.os.Build;
import androidx.exifinterface.media.ExifInterface;

import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.provider.ContactsContract;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.util.Log;
import android.view.ContextThemeWrapper;
import android.view.Gravity;
import android.view.Menu;
import android.view.MenuItem;
import android.content.Intent;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.View;
import android.view.WindowManager;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.net.Uri;
import android.os.Bundle;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.Toast;

import com.example.si.IMG_PROCESSING.CircleDetect.EdgeDetect_fun;
import com.example.si.IMG_PROCESSING.CornerDetection.ImageMarker;

import com.example.si.IMG_PROCESSING.CircleDetect.HoughCircle;
import com.example.si.IMG_PROCESSING.GSDT.GSDT_Para;
import com.example.si.IMG_PROCESSING.HessianMatrixLine;
import com.example.si.IMG_PROCESSING.CircleDetect.ImageFilter;
import com.example.si.IMG_PROCESSING.ImgObj_Para;
import com.example.si.IMG_PROCESSING.CircleDetect.Point;
import com.example.si.IMG_PROCESSING.Reconstruction3D.BundleAdjustment_LM;
import com.example.si.IMG_PROCESSING.Reconstruction3D.Convert2DTo3D;
import com.example.si.IMG_PROCESSING.Reconstruction3D.Convert2DTo3D_new;
import com.example.si.IMG_PROCESSING.Reconstruction3D.DataBuilder;
import com.lxj.xpopup.XPopup;
import com.lxj.xpopup.core.BasePopupView;
import com.lxj.xpopup.interfaces.OnSelectListener;


import org.opencv.android.OpenCVLoader;
import org.opencv.android.Utils;
import org.opencv.calib3d.Calib3d;
import org.opencv.core.DMatch;
import org.opencv.core.KeyPoint;
import org.opencv.core.Mat;
import org.opencv.core.MatOfDMatch;
import org.opencv.core.MatOfKeyPoint;
import org.opencv.core.MatOfPoint2f;
import org.opencv.features2d.DescriptorExtractor;
import org.opencv.features2d.DescriptorMatcher;
import org.opencv.features2d.FeatureDetector;
import org.opencv.features2d.Features2d;
import org.opencv.imgproc.Imgproc;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Objects;
import java.util.Set;


import Jama.Matrix;
import Jama.SingularValueDecomposition;

import static com.example.si.IMG_PROCESSING.Reconstruction3D.Convert2DTo3D.ArrayToMarkerList;
import static com.example.si.IMG_PROCESSING.Reconstruction3D.Convert2DTo3D.MarkerListToArray;
import static java.lang.Math.max;
import static java.lang.Math.min;

import static com.example.si.IMG_PROCESSING.GSDT.GSDT_2D.GSDT_Fun;
import static java.lang.Math.pow;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;

import static com.example.si.IMG_PROCESSING.CircleDetect.CircleDetect_new.CircleDetect_Fun;
import static java.lang.System.out;


public class MainActivity extends AppCompatActivity {
    private Button testbutton;
    private ImageView imageView;
    private Dialog dialog_pic;
    private static final int TAKE_PHOTO = 0;
    private static final int CHOOSE_PHOTO = 1;
    private static final int EdgeDetect = 2;
    private Uri photoURI;
    private String currentPhotoPath;
    private String currentPicturePath;
    private ScaleGestureDetector mScaleGestureDetector = null;
    private static MyGLSurfaceView myGLSurfaceView;
    private static MyRenderer myrenderer;
    private static Context context;
    private BasePopupView popupView;

    private Button img_switch;
    private Button select_points;
    private Button finished;
    private Button loadImage;
    private Button Process;
    private Button dimension_switch;
    private Boolean ImageOpened = false;
    private Boolean ImageOpened2 = false;
    private boolean isMutiImg = false;
    private boolean isP1 = true;
    private boolean ifPoint = false;
    private boolean ifDelete = false;
    private boolean isFinished1 = false;
    private boolean isFinished2 = false;
    private boolean isProcessed = false;
    private boolean isProcessed2 = false;
    private boolean ifDraw3D = false;
    private boolean ifDeletePointPair = false;

    private Bitmap showimg1 = null;
    private Bitmap showimg2 = null;
    private Bitmap img1 = null;
    private Bitmap img2 = null;
    private ArrayList<double[]> FfList = new ArrayList<>();
    ///////////////////////////////////
//    double[][] polist1 = new double[][]{{1052,758,1},{1851,2190,1},{3900,1356,1},{3138,1886,1},{787,2938,1},{1703,1799,1},{3027,1798,1},{2673,642,1},{3023,2381,1},{775,1985,1},{195,1601,1},{1294,2205,1},{3515,1543,1},{3882,896,1},{751,344,1},{2161,1428,1},{2458,64,1},{3060,2765,1},{3014,2123,1},{2556,2961,1},{1767,570,1},{706,2732,1},{519,1925,1},{573,567,1},{753,319,1},{1593,2379,1},{1864,2509,1},{2971,541,1},{3313,2610,1},{491,2456,1},{802,408,1},{1932,485,1},{3505,1101,1},{3636,2540,1},{1458,930,1},{3869,1111,1},{2777,2428,1},{405,2572,1},{901,1930,1},{978,1573,1},{3055,2967,1},{841,1566,1},{3214,1343,1},{2794,1116,1},{858,922,1},{2387,1063,1},{1989,2693,1},{3230,632,1},{332,1348,1},{1959,1850,1}};
//    double[][] polist2 = new double[][]{{1017.2,742.7,1},{1746.9,2183,1},{3825.9,1426.6,1},{3059,1799.4,1},{627.8,3078.1,1},{1597,1948.8,1},{2910.2,2032.8,1},{2604.4,929.9,1},{2880.9,2596.3,1},{665.9,2089.1,1},{122.3,1566.7,1},{1195.9,2145.5,1},{3444.4,1517.8,1},{3794.3,1238.7,1},{712,511,1},{2057,1699.1,1},{2425.3,288.3,1},{2928.5,2758.8,1},{2910.8,2135.1,1},{2410.2,2991.7,1},{1713.1,771,1},{558,2860.8,1},{394.9,2165.6,1},{535,645,1},{724.4,416.3,1},{1471.4,2436,1},{1743.6,2509.7,1},{2910.5,804.4,1},{3181.7,2658.9,1},{395.7,2282,1},{771.6,486.2,1},{1897.8,565.9,1},{3441.1,1186.1,1},{3484.6,2768.9,1},{1374.4,1225.8,1},{3789.9,1309.2,1},{2659.3,2438.6,1},{283.9,2553.2,1},{791.8,2055.6,1},{905,1551.4,1},{2900.1,3065.9,1},{747,1707.8,1},{3114,1615.6,1},{2736.6,1144.7,1},{791.8,1086.7,1},{2302.9,1315.1,1},{1843.7,2817.3,1},{3176,812.8,1},{243.8,1524.9,1},{1837.5,2100,1}};


//    double[][] polist1 = new double[][]{{1274,415,1},{1537,1007,1},{354,2652,1},{2276,1344,1},{1029,2173,1},{2356,1119,1},{2999,960,1},{317,827,1},{2100,3982,1},{1179,704,1},{1476,1255,1},{1112,2470,1},{2827,357,1},{2570,3346,1},{1725,2966,1},{100,3985,1},{1302,1010,1},{1561,1677,1},{785,2355,1},{268,3941,1},{637,154,1},{435,724,1},{1909,1438,1},{2267,1451,1},{2001,2358,1},{185,1901,1},{1492,3856,1},{1792,2626,1},{1779,1117,1},{114,2567,1},{2520,2034,1},{2140,1985,1},{514,3112,1},{377,1094,1},{676,3874,1},{2554,1692,1},{2870,797,1},{1643,3447,1},{904,2698,1},{511,532,1},{276,3822,1},{1876,3750,1},{2131,304,1},{348,3235,1},{772,2021,1},{2341,1881,1},{1639,2777,1},{2658,1626,1},{293,2333,1},{2357,2986,1}};
//
//    double[][] polist2 = new double[][]{{1.23076104E3,5.90092851E2,1},{1.47187979E3,1.13355665E3,1},{2.33181897E2,2.60191686E3,1},{2.19760944E3,1.44998958E3,1},{8.97328699E2,2.38214152E3,1},{2.27887361E3,1.29769766E3,1},{2.93354165E3,1.10838301E3,1},{2.70210802E2,8.77281067E2,1},{1.92740782E3,3.84452219E3,1},{1.12452499E3,8.59329398E2,1},{1.42383670E3,1.19155330E3,1},{1.00490169E3,2.38246083E3,1},{2.78227287E3,5.66876808E2,1},{2.41912890E3,3.27540264E3,1},{1.57139467E3,3.05411534E3,1},{-6.11803886e+01,3.75622434E3,1},{1.25794155E3,9.73829896E2,1},{1.48176842E3,1.66665726E3,1},{6.82888070E2,2.27086740E3,1},{1.04816899E2,3.74388737E3,1},{6.24524517E2,1.88041404E2,1},{3.59050081E2,1.03543694E3,1},{1.80367908E3,1.71534575E3,1},{2.19942593E3,1.43501200E3,1},{1.88424515E3,2.38661728E3,1},{6.44204259e+01,2.12347716E3,1},{1.31005001E3,3.83541132E3,1},{1.67992247E3,2.52050159E3,1},{1.69674445E3,1.33490133E3,1},{-1.48708416e+01,2.60933437E3,1},{2.42930534E3,1.98224418E3,1},{2.05532724E3,1.90451125E3,1},{3.46414454E2,3.25209504E3,1}
//            ,{3.15868498E2,1.15656889E3,1},{4.97283656E2,3.82092025E3,1},{2.45446031E3,1.83309283E3,1},{2.80984547E3,9.64188685E2,1},{1.47506955E3,3.46881744E3,1},{8.01933758E2,2.48825687E3,1},{4.87662170E2,5.10827155E2,1},{9.87477712e+01,3.77616180E3,1},{1.73432217E3,3.46028967E3,1},{2.07616079E3,6.09724564E2,1},{2.02895909E2,3.15771106E3,1},{6.95163950E2,1.86541176E3,1},{2.23167649E3,2.02760987E3,1},{1.51169166E3,2.73271394E3,1},{2.54928051E3,1.86167629E3,1},{1.87057196E2,2.28556097E3,1},{2.20055924E3,3.08940293E3,1}};


//    double[][] polist1 = new double[][]{{414,26,1},{291,176,1},{313,331,1},{333,166,1},{326,77,1},{113,86,1},{27,376,1},{156,253,1},{145,501,1},{367,255,1},{128,118,1},{167,280,1},{516,212,1},{187,281,1},{44,409,1},{172,128,1},{216,109,1},{95,58,1},{437,554,1},{70,61,1},{536,407,1},{145,36,1},{150,135,1},{227,244,1},{224,355,1},{99,264,1},{35,173,1},{122,252,1},{93,228,1},{315,188,1},{311,323,1},{426,396,1},{86,460,1},{212,207,1},{156,115,1},{80,451,1},{434,403,1}
//            ,{211,342,1},{465,24,1},{15,284,1},{59,192,1},{198,83,1},{265,174,1},{270,61,1},{370,242,1},{378,132,1},{381,361,1},{87,38,1},{132,241,1},{101,190,1}};
//
//    double[][] polist2 = new double[][]{{-1.33779634E3,2.79879007E1,1},{-1.48352742E3,1.94448985E2,1},{-1.45483107E3,3.62460413E2,1},{-1.43328292E3,1.81719148E2,1},{-1.43960597E3,8.43534916E1,1},{-1.70478330E3,9.83061236E1,1},{-1.81545924E3,4.33694521E2,1},{-1.64854639E3,2.84774872E2,1},{-1.66428341E3,5.65636917E2,1},{-1.39155324E3,2.76861249E2,1},{-1.68569933E3,1.33417468E2,1},{-1.63408949E3,3.14729116E2,1},{-1.22300693E3,2.24507688E2,1},{-1.61034738E3,3.15094302E2,1},{-1.79463278E3,4.70188651E2,1},{-1.62810391E3,1.43566468E2,1},{-1.57394321E3,1.21479770E2,1},{-1.72580536E3,6.60407563E1,1},{-1.31193666E3,5.94785347E2,1},{-1.75881539E3,6.97028924E1,1},{-1.20063089E3,4.29387208E2,1},{-1.66263228E3,4.09631067E1,1},{-1.65539471E3,1.52368335E2,1},{-1.55979184E3,2.71971996E2,1},{-1.56446282E3,3.95109126E2,1},{-1.72059603E3,3.00840889E2,1},{-1.80567006E3,1.99413005E2,1},{-1.69339287E3,2.86017799E2,1},{-1.72919413E3,2.59705597E2,1},{-1.45380169E3,2.06230340E2,1},{-1.45775345E3,3.53719673E2,1},{-1.32538168E3,4.26090292E2,1},{-1.73968032E3,5.24321489E2,1},{-1.57814876E3,2.30782057E2,1},{-1.64789226E3,1.30261863E2,1},{-1.74761143E3,5.14391840E2,1},{-1.31458524E3,4.32686969E2,1},{-1.58048763E3,3.81591976E2,1},{-1.27887877E3,2.62969983E1,1},{-1.83170388E3,3.27629610E2,1},{-1.77278190E3,2.20231144E2,1},{-1.59811556E3,9.35460019E1,1},{-1.51412345E3,1.92105790E2,1},{-1.50721054E3,6.78950862E1,1},{-1.38823903E3,2.62689570E2,1},{-1.37968557E3,1.43615107E2,1},{-1.37545463E3,3.90674830E2,1},{-1.73727989E3,4.33323957E1,1},{-1.68047676E3,2.72737170E2,1},{-1.71789902E3,2.16062993E2,1}};

//    double[][] polist1 = new double[][]{{143,530,1},{426,274,1},{789,60,1},{149,395,1},{392,115,1},{866,866,1},{831,146,1},{265,751,1},{1286,68,1},{788,44,1},{495,1352,1},{619,69,1},{709,971,1},{819,433,1},{137,1160,1},{302,741,1},{448,543,1},{123,742,1},{183,806,1},{1312,714,1},{87,1259,1},{276,112,1},{307,353,1},{675,410,1},{669,143,1},{1334,279,1},{125,1244,1},{729,1046,1},{533,946,1},{952,416,1},{46,797,1},{382,116,1},{1020,98,1},{290,590,1},{162,718,1},{881,401,1},{552,91,1},{299,207,1},{643,203,1},{255,520,1},{311,72,1},{1252,540,1},{289,651,1},{285,75,1},{740,805,1},{1243,1249,1},{730,717,1},{757,381,1}
//            ,{334,259,1},{255,448,1}};
//
//    double[][] polist2 = new double[][]{{-1.66508060E3,5.97800394E2,1},{-1.32380770E3,2.94874798E2,1},{-9.30737018E2,6.10165344E1,1},{-1.65711652E3,4.44969031E2,1},{-1.36165324E3,1.24859736E2,1},{-8.52900159E2,8.66352064E2,1},{-8.86667684E2,1.46872615E2,1},{-1.51509981E3,8.29946153E2,1},{-4.58097396E2,6.44699006E1,1},{-9.30294127E2,4.50162070E1,1},{-1.24599630E3,1.43558404E3,1},{-1.10839056E3,7.27723654E1,1},{-1.01277341E3,9.95588520E2,1},{-8.99828827E2,4.36325600E2,1},{-1.67554186E3,1.31008596E3,1},{-1.46802492E3,8.12461810E2,1},{-1.29860737E3,5.81024679E2,1},{-1.69083533E3,8.39393083E2,1},{-1.61503002E3,9.02651956E2,1},{-4.35462800E2,6.67784369E2,1},{-1.73967171E3,1.43397899E3,1},{-1.50046367E3,1.23642203E2,1},{-1.46399478E3,3.87553392E2,1},{-1.04850928E3,4.22744155E2,1},{-1.05464107E3,1.48198053E2,1},{-4.16862242E2,2.60692250E2,1},{-1.68908683E3,1.40710160E3,1},{-9.92500282E2,1.06913628E3,1},{-1.20254565E3,9.97917583E2,1},{-7.66666798E2,4.10433984E2,1},{-1.79043594E3,9.13690051E2,1},{-1.37468115E3,1.25984164E2,1},{-7.01679368E2,9.57705821E1,1},{-1.48276952E3,6.48824925E2,1},{-1.64074997E3,8.07257093E2,1},{-8.36408259E2,4.00679106E2,1},{-1.18110403E3,9.57673583E1,1},{-1.47252930E3,2.27980029E2,1},{-1.08130906E3,2.10504396E2,1},{-1.52579268E3,5.75155246E2,1},{-1.45746587E3,7.90201450E1,1},{-4.88515656E2,5.10147595E2,1},{-1.48418003E3,7.16230678E2,1},{-1.49000220E3,8.27360563E1,1},{-9.79882237E2,8.20978191E2,1},{-4.96663830E2,1.18004740E3,1},{-9.89346634E2,7.32323510E2,1},{-9.62442239E2,3.88326475E2,1},{-1.43045481E3,2.83168219E2,1},{-1.52686250E3,4.96340551E2,1}};

    //0916
//    double[][] polist1 = new double[][]{{873,70,1},{1137,213,1},{196,303,1},{113,868,1},{142,716,1},{29,616,1},{814,801,1},{270,472,1},{330,912,1},{1097,918,1},{62,256,1},{798,699,1},{286,481,1},{819,117,1},{125,778,1},{519,676,1},{501,140,1},{475,1299,1}
//            ,{575,46,1},{625,54,1},{318,660,1},{576,367,1},{635,305,1},{461,517,1},{307,93,1},{733,595,1},{1027,579,1},{896,787,1},{353,372,1},{1128,605,1},{1113,1053,1},{444,492,1},{720,446,1},{62,318,1},{79,442,1},{531,109,1},{688,1253,1},{38,1217,1},{553,445,1},{212,487,1},{299,1071,1},{256,418,1},{786,707,1},{653,414,1},{483,468,1},{207,1304,1},{628,560,1},{615,1119,1},{711,891,1},{1057,350,1}};
//    double[][] polist2 = new double[][]{{-8.44149417E02,-7.01243716E01,1.00000000E00},{-5.92102316E02,-2.04821874E02,1.00000000E00},{-1.59848844E03,-3.39181688E02,1.00000000E00},{-1.70279784E03,-9.83655419E02,1.00000000E00},{-1.66813960E03,-8.08492588E02,1.00000000E00},{-1.81199751E03,-7.09261686E02,1.00000000E00},{-9.04794917E02,-8.07880563E02,1.00000000E00},{-1.50803293E03,-5.20834314E02,1.00000000E00},{-1.43617096E03,-9.95336895E02,1.00000000E00},{-6.29134719E02,-8.86470760E02,1.00000000E00},{-1.77018217E03,-2.93223726E02,1.00000000E00},{-9.19294712E02,-7.06440991E02,1.00000000E00},{-1.48819709E03,-5.29095734E02,1.00000000E00},{-8.98749267E02,-1.18135906E02,1.00000000E00},{-1.68825220E03,-8.80435997E02,1.00000000E00},{-1.21782479E03,-7.14497160E02,1.00000000E00},{-1.23792301E03,-1.49369843E02,1.00000000E00},{-1.26810098E03,-1.38421217E03,1.00000000E00},{-1.15559234E03,-4.90521446E01,1.00000000E00},{-1.10060089E03,-5.68823027E01,1.00000000E00},{-1.45151583E03,-7.22214619E02,1.00000000E00},{-1.15437274E03,-3.85116382E02,1.00000000E00},{-1.09083292E03,-3.16708690E02,1.00000000E00},{-1.28207605E03,-5.52121303E02,1.00000000E00},{-1.46448780E03,-1.02709208E02,1.00000000E00},{-9.86490505E02,-6.07864730E02,1.00000000E00},{-6.95043360E02,-5.64985542E02,1.00000000E00},{-8.21441961E02,-7.83381425E02,1.00000000E00},{-1.41000788E03,-4.04491874E02,1.00000000E00},{-6.01312558E02,-5.82226435E02,1.00000000E00},{-6.13874035E02,-1.01415901E03,1.00000000E00},{-1.30262340E03,-5.27113328E02,1.00000000E00},{-1.00072079E03,-4.56328273E02,1.00000000E00},{-1.76970994E03,-3.64600846E02,1.00000000E00},{-1.74734987E03,-5.04008143E02,1.00000000E00},{-1.20543106E03,-1.15298453E02,1.00000000E00},{-1.03584870E03,-1.28920746E03,1.00000000E00},{-1.80367559E03,-1.39848112E03,1.00000000E00},{-1.17936298E03,-4.68375869E02,1.00000000E00},{-1.57898005E03,-5.42735616E02,1.00000000E00},{-1.47289645E03,-1.17519136E03,1.00000000E00},{-1.52446381E03,-4.62410369E02,1.00000000E00},{-9.32013334E02,-7.15958523E02,1.00000000E00},{-1.07089308E03,-4.28351193E02,1.00000000E00},{-1.25792850E03,-4.97683613E02,1.00000000E00},{-1.58638334E03,-1.45427847E03,1.00000000E00},{-1.09740741E03,-5.82286041E02,1.00000000E00},{-1.11377277E03,-1.16500766E03,1.00000000E00},{-1.00964670E03,-9.12979286E02,1.00000000E00},{-6.67312107E02,-3.40453656E02,1.00000000E00}};

//    0916 第二组
//    double[][] f = new double[][]{{ 9.76562500E-8, 3.05175781E-11, 5.41265877E-04}, {-8.45463643E-08, 1.79428994E-22, -4.68798828E-04},{-5.41265877E-04, -5.41265877E-04, 1.00000000E+00}};
//    double[][] polist1 = new double[][]{{2906,880,1},{3792,3081,1},{3388,3078,1},{665,3702,1},{1246,999,1},{1269,514,1},{2568,1467,1},{1286,392,1},{3750,3704,1},{5362,5945,1},{1417,829,1},{8533,3093,1},{646,1235,1},{9315,12515,1},{356,240,1},{306,1390,1},{886,804,1},{2745,7113,1},{508,1560,1},{946,1321,1},{269,950,1},{4660,914,1},{436,737,1},{811,1238,1},{237,1118,1},{437,669,1},{6482,1856,1},{692,881,1},{964,524,1},{550,1380,1},{1533,1288,1},{754,727,1},{5092,4732,1},{7221,3473,1},{1576,3546,1},{1268,690,1},{1796,892,1},{1051,1841,1},{7971,4631,1},{3058,4541,1},{5066,8164,1},{1600,7870,1},{1331,1257,1},{2638,697,1},{654,1083,1},{1718,519,1},{2856,1348,1},{1507,424,1},{1220,2309,1},{3761,6689,1}};
//    double[][] polist2 = new double[][]{{6.87662285E02,-6.48811561E02,1.00000000E00},{1.15206708E03,-2.10625122E03,1.00000000E00},{9.51513370E02,-2.19866703E03,1.00000000E00},{-1.07414276E03,-3.81733001E03,1.00000000E00},{-4.95715281E02,-9.35629856E02,1.00000000E00},{-4.74799783E02,-4.77192404E02,1.00000000E00},{4.87734463E02,-1.14882457E03,1.00000000E00},{-4.63062488E02,-3.55936831E02,1.00000000E00},{1.13204476E03,-2.54577683E03,1.00000000E00},{1.78596981E03,-3.48826472E03,1.00000000E00},{-3.51416289E02,-7.50142766E02,1.00000000E00},{2.63955399E03,-1.38626815E03,1.00000000E00},{-1.08150125E03,-1.27329227E03,1.00000000E00},{2.79366363E03,-5.40513840E03,1.00000000E00},{-1.40821633E03,-2.52903928E02,1.00000000E00},{-1.46753869E03,-1.51615799E03,1.00000000E00},{-8.33719246E02,-7.95086487E02,1.00000000E00},{5.89411897E02,-5.50911658E03,1.00000000E00},{-1.23759647E03,-1.64367492E03,1.00000000E00},{-7.74656760E02,-1.29858197E03,1.00000000E00},{-1.51301632E03,-1.04041374E03,1.00000000E00},{1.52662635E03,-5.59991109E02,1.00000000E00},{-1.31451058E03,-7.83771635E02,1.00000000E00},{-9.09992096E02,-1.24152557E03,1.00000000E00},{-1.55203701E03,-1.23245929E03,1.00000000E00},{-1.32257989E03,-7.01277994E02,1.00000000E00},{2.13784368E03,-9.75310102E02,1.00000000E00},{-1.03220713E03,-8.99346738E02,1.00000000E00},{-7.59743384E02,-5.06901890E02,1.00000000E00},{-1.19011681E03,-1.44178503E03,1.00000000E00},{-2.50468340E02,-1.15946188E03,1.00000000E00},{-9.67400208E02,-7.34231770E02,1.00000000E00},{1.69016206E03,-2.84148691E03,1.00000000E00},{2.33623285E03,-1.73056870E03,1.00000000E00},{-2.23344087E02,-3.18528552E03,1.00000000E00},{-4.76615996E02,-6.41595473E02,1.00000000E00},{-4.31915000E01,-7.70950434E02,1.00000000E00},{-6.79444016E02,-1.77985285E03,1.00000000E00},{2.51655590E03,-2.18247385E03,1.00000000E00},{7.70331774E02,-3.37591143E03,1.00000000E00},{1.68065554E03,-4.93327481E03,1.00000000E00},{-2.13688489E02,-7.08762887E03,1.00000000E00},{-4.20858949E02,-1.16597164E03,1.00000000E00},{5.31467878E02,-5.35104334E02,1.00000000E00},{-1.07306938E03,-1.11370538E03,1.00000000E00},{-1.02638887E02,-4.50415011E02,1.00000000E00},{6.62134373E02,-1.01878939E03,1.00000000E00},{-2.73149026E02,-3.76765370E02,1.00000000E00},{-5.21765931E02,-2.18015116E03,1.00000000E00},{1.13576973E03,-4.60710163E03,1.00000000E00}};
//0916 第三组
//    double[][] f = new double[][]{{ 9.76562500e-08, 2.03450521e-11, 5.41265877e-04}, {1.12939918e-08, -2.38939673e-23, 6.24674479e-05},{-5.41265877e-04, 7.21687836e-05, 1.00000000e+00}};
//    double[][] polist1 = new double[][]{{3164,3413,1},{4775,4233,1},{3942,4155,1},{2886,2696,1},{3140,2635,1},{3222,3252,1},{2528,3185,1},{4167,3282,1},{3672,2921,1},{3104,2960,1},{3416,5103,1},{3777,4090,1},{4188,3774,1},{3920,3810,1},{2556,2615,1},{4353,4633,1},{3109,4370,1},{4044,4142,1},{2527,2520,1},{3266,3704,1},{2878,3514,1},{3171,3475,1},{2954,2450,1},{2350,2633,1},{2594,2669,1},{3108,3417,1},{2760,3832,1},{2123,2315,1},{3215,3751,1},{3310,4353,1},{3133,3067,1},{3006,4263,1},{3583,3688,1},{2254,2700,1},{2656,2166,1},{2729,4302,1},{3077,3621,1},{2613,2607,1},{2835,3418,1},{3167,2485,1},{2758,3043,1},{2055,3128,1},{2612,2709,1},{3111,4393,1},{3342,2771,1},{2984,4603,1},{2532,2793,1},{2743,2666,1},{3112,2372,1},{2782,4382,1}};
//    double[][] polist2 = new double[][]{{8.12699278E+02,-2.57329568E+03,1.00000000E+00},{1.53818171E+03,-2.69992347E+03,1.00000000E+00},{1.19367624E+03,-2.87255388E+03,1.00000000E+00},{6.53761413E+02,-2.12718830E+03,1.00000000E+00},{7.94468424E+02,-2.02326440E+03,1.00000000E+00},{8.42575606E+02,-2.44247008E+03,1.00000000E+00},{4.41265770E+02,-2.59766497E+03,1.00000000E+00},{1.28754786E+03,-2.24869449E+03,1.00000000E+00},{1.06759006E+03,-2.10347016E+03,1.00000000E+00},{7.76957300E+02,-2.26542320E+03,1.00000000E+00},{9.33608145E+02,-3.72654386E+03,1.00000000E+00},{1.11270650E+03,-2.88874651E+03,1.00000000E+00},{1.29567538E+03,-2.56756252E+03,1.00000000E+00},{1.17824469E+03,-2.65887675E+03,1.00000000E+00},{4.55203550E+02,-2.15183333E+03,1.00000000E+00},{1.36661864E+03,-3.07525584E+03,1.00000000E+00},{7.72127665E+02,-3.31856342E+03,1.00000000E+00},{1.23842236E+03,-2.83601568E+03,1.00000000E+00},{4.41827817E+02,-2.07042954E+03,1.00000000E+00},{8.66340760E+02,-2.75639681E+03,1.00000000E+00},{6.53057791E+02,-2.73617983E+03,1.00000000E+00},{8.16906108E+02,-2.61561991E+03,1.00000000E+00},{6.98823693E+02,-1.90843312E+03,1.00000000E+00},{3.28156356E+02,-2.20785034E+03,1.00000000E+00},{4.79536851E+02,-2.18189216E+03,1.00000000E+00},{7.77732354E+02,-2.60346394E+03,1.00000000E+00},{5.81914148E+02,-3.02363333E+03,1.00000000E+00},{1.75046908E+02,-2.00841396E+03,1.00000000E+00},{8.38174439E+02,-2.80817496E+03,1.00000000E+00},{8.79918524E+02,-3.23075183E+03,1.00000000E+00},{7.95452317E+02,-2.33049744E+03,1.00000000E+00},{7.16910260E+02,-3.27454979E+03,1.00000000E+00},{1.01989220E+03,-2.66824212E+03,1.00000000E+00},{2.65780628E+02,-2.28587110E+03,1.00000000E+00},{5.23393347E+02,-1.75876627E+03,1.00000000E+00},{5.59015648E+02,-3.40796873E+03,1.00000000E+00},{7.63430785E+02,-2.75675688E+03,1.00000000E+00},{4.96787354E+02,-2.11291838E+03,1.00000000E+00},{6.24631861E+02,-2.68641966E+03,1.00000000E+00},{8.10853165E+02,-1.90335680E+03,1.00000000E+00},{5.83923103E+02,-2.41160723E+03,1.00000000E+00},{1.28882765E+02,-2.70139355E+03,1.00000000E+00},{4.97187424E+02,-2.19035748E+03,1.00000000E+00},{7.77926999E+02,-3.32356052E+03,1.00000000E+00},{9.08388278E+02,-2.05854901E+03,1.00000000E+00},{7.05744113E+02,-3.53352589E+03,1.00000000E+00},{4.42832874E+02,-2.29004450E+03,1.00000000E+00},{5.74486027E+02,-2.12840590E+03,1.00000000E+00},{7.84287943E+02,-1.82436091E+03,1.00000000E+00},{5.90611423E+02,-3.44601533E+03,1.00000000E+00}};
////0917 第1组
//    double[][] polist1 = new double[][]{{3573,2958,1},{2188,2532,1},{3618,3669,1},{2521,2401,1},{2372,2887,1},{2807,3976,1},{3336,3449,1},{3577,4068,1},{4388,3433,1},{2494,2556,1}};
//    double[][] polist2 = new double[][]{{1.77397780E+04,1.78555692E+04,1.00000000E+00},{6.32917662E+03,7.29703798E+03,1.00000000E+00},{1.86418343E+04,2.27668074E+04,1.00000000E+00},{7.93203113E+03,8.08313197E+03,1.00000000E+00},{7.03799069E+03,8.80753612E+03,1.00000000E+00},{9.23179337E+03,1.44996313E+04,1.00000000E+00},{1.42949175E+04,1.73272972E+04,1.00000000E+00},{1.80432059E+04,2.46219772E+04,1.00000000E+00},{5.56768763E+04,5.62764546E+04,1.00000000E+00},{7.76499665E+03,8.41751256E+03,1.00000000E+00}};
    //0918 第1组
//    double[][] polist1 = new double[][]{{1823,3681,1},{2457,1659,1},{3348,2669,1},{3080,2751,1},{3213,2609,1},{4339,3097,1},{1595,1219,1},{3627,5190,1},{7234,4014,1},{2587,3163,1}};
//
//    double[][] polist2 = new double[][]{{4.53289749e+03,5.69593470e+03,1.00000000e+00},{5.03865477e+03,2.81092155e+03,1.00000000e+00},{6.63592646e+03,4.51297660e+03,1.00000000e+00},{6.21649953e+03,4.50121859e+03,1.00000000e+00},{6.38414558e+03,4.32746684e+03,1.00000000e+00},{8.46332310e+03,5.50552590e+03,1.00000000e+00},{3.82693413e+03,2.09918247e+03,1.00000000e+00},{8.18452766e+03,9.46045001e+03,1.00000000e+00},{1.52607722e+04,8.61434289e+03,1.00000000e+00},{5.58639076e+03,5.10140152e+03,1.00000000e+00}};
//0918 第2组
//    double[][] f = new double[][]{{ 4.25177349e-09,-1.16218716e-07,-5.25406503e-04}, {1.90791915e-07,6.92168081e-08,-1.50756152e-03},{5.63402687e-04,1.50979280e-03,1.00000000e+00}};
//    double[][] polist1 = new double[][]{{2542,1652,1},{1950,2167,1},{3259,4071,1},{3598,2210,1},{2766,1648,1},{2163,3086,1},{4096,2461,1},{5082,3639,1},{1408,2095,1},{1430,1832,1},{5149,3567,1},{497,1531,1},{1237,2453,1},{838,1174,1},{1106,1632,1},{2377,3883,1},{2872,2830,1},{2039,961,1},{1793,677,1},{2670,2219,1}};
//    double[][] polist2 = new double[][]{{3.28331721e+03,2.87039371e+03,1.00000000e+00},{2.54386348e+03,3.46667985e+03,1.00000000e+00},{4.76664016e+03,7.10474370e+03,1.00000000e+00},{4.88733800e+03,3.91615156e+03,1.00000000e+00},{3.60328745e+03,2.89647319e+03,1.00000000e+00},{2.90329712e+03,4.92368695e+03,1.00000000e+00},{5.73885761e+03,4.44139839e+03,1.00000000e+00},{7.93386752e+03,7.01139048e+03,1.00000000e+00},{1.84365428e+03,3.24657145e+03,1.00000000e+00},{1.87288261e+03,2.88928034e+03,1.00000000e+00},{8.03204004e+03,6.87844593e+03,1.00000000e+00},{7.50699132e+02,2.34675114e+03,1.00000000e+00},{1.66405198e+03,3.68632075e+03,1.00000000e+00},{1.17372445e+03,1.95270822e+03,1.00000000e+00},{1.46561996e+03,2.57443085e+03,1.00000000e+00},{3.30615636e+03,6.37687883e+03,1.00000000e+00},{3.91775157e+03,4.70498747e+03,1.00000000e+00},{2.58458558e+03,1.87896656e+03,1.00000000e+00},{2.27411014e+03,1.49911022e+03,1.00000000e+00},{3.53190849e+03,3.70561806e+03,1.00000000e+00}};
    //0919 第1组
//    double[][] f = new double[][]{{ 4.22188611e-09,-2.71915752e-07,-1.02065209e-03}, {3.62762688e-07,4.31002651e-08,-1.25804335e-03},{9.49353787e-04,1.27510792e-03,1.00000000e+00}};
//    double[][] polist1 = new double[][]{{537,537,1},{680,1906,1},{3471,3169,1},{1666,5623,1},{4184,4465,1},{2627,2697,1},{1148,1936,1},{4393,3615,1},{1884,3622,1},{1507,3982,1},{479,1798,1},{5590,2120,1},{1770,1340,1},{5239,2745,1},{3046,2496,1},{4251,4653,1},{3867,4354,1},{2823,2373,1},{3067,672,1},{1921,1124,1}};
//    double[][] polist2 = new double[][]{{8.23513425e+02,1.18927488e+03,1.00000000e+00},{9.23653970e+02,2.86061073e+03,1.00000000e+00},{4.87035006e+03,5.50581661e+03,1.00000000e+00},{2.27551429e+03,9.64622417e+03,1.00000000e+00},{6.52660049e+03,8.40840534e+03,1.00000000e+00},{3.49739860e+03,4.44623408e+03,1.00000000e+00},{1.48564265e+03,2.99298948e+03,1.00000000e+00},{6.58270874e+03,6.68619338e+03,1.00000000e+00},{2.50487909e+03,5.74547628e+03,1.00000000e+00},{1.97251447e+03,6.25065207e+03,1.00000000e+00},{6.92165422e+02,2.68692010e+03,1.00000000e+00},{8.09242479e+03,4.32300564e+03,1.00000000e+00},{2.24601017e+03,2.32193302e+03,1.00000000e+00},{7.75566351e+03,5.33502051e+03,1.00000000e+00},{4.08152883e+03,4.24594730e+03,1.00000000e+00},{6.73591099e+03,8.88749820e+03,1.00000000e+00},{5.88946738e+03,8.00623594e+03,1.00000000e+00},{3.73710218e+03,3.99567164e+03,1.00000000e+00},{3.84249849e+03,1.67474286e+03,1.00000000e+00},{2.42514953e+03,2.07048866e+03,1.00000000e+00}};
//0920 第1组
//    double[][] f = new double[][]{{-2.89568161e-08,-6.33544299e-07,-9.64528064e-04},{7.18715856e-07,1.90191455e-08,-1.28632016e-03},{7.03207019e-04,1.42478213e-03,1.00000000e+00}};
//    double[][] polist1 = new double[][]{{2219,418,1},{2260,3728,1},{3253,983,1},{4660,4939,1},{6259,4568,1},{972,1369,1},{7098,5462,1},{2358,3000,1},{3857,2006,1},{3103,1881,1},{2861,3441,1},{3171,1028,1},{2440,2279,1},{2382,1696,1},{1831,3930,1},{3444,2965,1},{1550,1350,1},{2348,4587,1},{2890,3423,1},{1452,3024,1},{2458,3503,1},{5520,1023,1},{1377,4266,1},{2214,1683,1},{1693,2826,1},{3041,2883,1},{974,2777,1},{2914,710,1},{3177,567,1},{2774,4559,1}};
//    double[][] polist2 = new double[][]{{2.74280776e+03,1.23875075e+03,1.00000000e+00},{3.05302772e+03,5.99675411e+03,1.00000000e+00},{4.11104463e+03,2.07742132e+03,1.00000000e+00},{7.54946915e+03,9.55259116e+03,1.00000000e+00},{1.07685129e+04,9.57709943e+03,1.00000000e+00},{1.28832320e+03,2.20438509e+03,1.00000000e+00},{1.39026400e+04,1.29100931e+04,1.00000000e+00},{3.12324227e+03,4.78597451e+03,1.00000000e+00},{5.15444689e+03,3.62663871e+03,1.00000000e+00},{4.04153134e+03,3.28184663e+03,1.00000000e+00},{3.92274382e+03,5.67658713e+03,1.00000000e+00},{4.00702578e+03,2.12147226e+03,1.00000000e+00},{3.16686493e+03,3.69495288e+03,1.00000000e+00},{3.03993349e+03,2.87363487e+03,1.00000000e+00},{2.43384944e+03,6.19635630e+03,1.00000000e+00},{4.74330780e+03,5.06641357e+03,1.00000000e+00},{1.97473667e+03,2.26224607e+03,1.00000000e+00},{3.27329582e+03,7.57678357e+03,1.00000000e+00},{3.97296846e+03,5.69037085e+03,1.00000000e+00},{1.87543569e+03,4.58338503e+03,1.00000000e+00},{3.32582902e+03,5.67950208e+03,1.00000000e+00},{7.40200466e+03,2.51084281e+03,1.00000000e+00},{1.78923447e+03,6.57977315e+03,1.00000000e+00},{2.81435863e+03,2.79149119e+03,1.00000000e+00},{2.19344981e+03,4.32603663e+03,1.00000000e+00},{4.08860535e+03,4.74036311e+03,1.00000000e+00},{1.26730957e+03,4.04232287e+03,1.00000000e+00},{3.63144851e+03,1.68158360e+03,1.00000000e+00},{3.94558318e+03,1.53188582e+03,1.00000000e+00},{3.96553855e+03,7.74455282e+03,1.00000000e+00}};
// 0921 第1组
    double[][] f = new double[][]{{2.25317821e-08,-4.26544354e-07,-2.18073810e-03},{5.57633751e-07,-3.09814609e-09,-6.73560544e-04},{1.96553960e-03,6.57196855e-04,1.00000000e+00}};
    double[][] polist1 = new double[][]{{4.73603749e+02,5.61175588e+02,1.00000000e+00},{2.11736655e+03,2.55818057e+03,1.00000000e+00},{2.18594468e+03,1.96903038e+03,1.00000000e+00},{3.09951950e+03,2.07457522e+03,1.00000000e+00},{6.80449567e+03,2.37973462e+03,1.00000000e+00},{3.72940113e+03,1.26736174e+03,1.00000000e+00},{3.32729173e+03,4.72302850e+03,1.00000000e+00},{4.71647349e+03,5.87286615e+03,1.00000000e+00},{1.47441143e+03,1.77116155e+03,1.00000000e+00},{5.97965867e+03,3.73202847e+03,1.00000000e+00},{1.99422790e+03,5.91006914e+02,1.00000000e+00},{2.95425299e+03,3.42339180e+03,1.00000000e+00},{3.29767154e+03,6.87518602e+02,1.00000000e+00},{5.46042813e+03,2.55813680e+03,1.00000000e+00},{6.76314393e+03,4.21329884e+03,1.00000000e+00},{8.63230683e+02,3.16688954e+03,1.00000000e+00},{1.61153340e+03,1.90362175e+03,1.00000000e+00},{4.73621859e+03,2.75791517e+03,1.00000000e+00},{9.88397587e+02,3.34059645e+03,1.00000000e+00},{4.47799297e+03,1.02092570e+03,1.00000000e+00},{4.99531560e+03,4.38873741e+03,1.00000000e+00},{6.37587760e+03,6.79078221e+03,1.00000000e+00},{7.35581646e+03,7.65499580e+03,1.00000000e+00},{3.39468037e+03,3.86846953e+03,1.00000000e+00},{7.09115740e+02,2.62317832e+03,1.00000000e+00},{7.47188570e+02,2.67132868e+03,1.00000000e+00},{1.18813910e+03,5.71455544e+03,1.00000000e+00},{1.03946635e+03,6.25969169e+02,1.00000000e+00},{2.10491074e+03,5.40343261e+03,1.00000000e+00},{7.65575428e+02,1.05335433e+03,1.00000000e+00}};
    double[][] polist2 = new double[][]{{7.56933236e+02,1.15736302e+03,1.00000000e+00},{2.73768841e+03,3.97388779e+03,1.00000000e+00},{2.77192029e+03,3.05172463e+03,1.00000000e+00},{4.03029418e+03,3.45124686e+03,1.00000000e+00},{1.02373115e+04,4.88468580e+03,1.00000000e+00},{4.79041797e+03,2.47515725e+03,1.00000000e+00},{4.87863406e+03,8.10285828e+03,1.00000000e+00},{8.13911797e+03,1.19398338e+04,1.00000000e+00},{1.87979468e+03,2.75980048e+03,1.00000000e+00},{9.47869296e+03,7.27594511e+03,1.00000000e+00},{2.47215976e+03,1.36289231e+03,1.00000000e+00},{4.03825006e+03,5.58310710e+03,1.00000000e+00},{4.10742275e+03,1.65320672e+03,1.00000000e+00},{7.88038538e+03,4.82364956e+03,1.00000000e+00},{1.15772034e+04,8.82618900e+03,1.00000000e+00},{1.09631912e+03,4.59192567e+03,1.00000000e+00},{2.05000995e+03,2.92934918e+03,1.00000000e+00},{6.68167846e+03,4.89868626e+03,1.00000000e+00},{1.25280108e+03,4.88828046e+03,1.00000000e+00},{5.79072106e+03,2.24837437e+03,1.00000000e+00},{7.84706483e+03,8.20437865e+03,1.00000000e+00},{1.32793756e+04,1.66110035e+04,1.00000000e+00},{1.82755319e+04,2.23256552e+04,1.00000000e+00},{4.83871104e+03,6.58529207e+03,1.00000000e+00},{9.26294901e+02,3.75916096e+03,1.00000000e+00},{9.70911180e+02,3.83501162e+03,1.00000000e+00},{1.48744078e+03,9.10106186e+03,1.00000000e+00},{1.37422911e+03,1.28236270e+03,1.00000000e+00},{2.93993948e+03,9.01689956e+03,1.00000000e+00},{1.05970287e+03,1.71358716e+03,1.00000000e+00}};


    //        double[][] X = new double[][]{{1052,758,90,1},{1851,2190,389,1},{3900,1356,343,1},{3138,1886,89,1},{787,2938,943,1},{1703,1799,699,1},{3027,1798,869,1},{2673,642,767,1},{3023,2381,944,1},{775,1985,653,1},{195,1601,247,1},{1294,2205,279,1},{3515,1543,157,1},{3882,896,920,1},{751,344,463,1},{2161,1428,907,1},{2458,64,494,1},{3060,2765,476,1},{3014,2123,387,1},{2556,2961,624,1},{1767,570,564,1},{706,2732,874,1},{519,1925,986,1},{573,567,295,1},{753,319,285,1},{1593,2379,595,1},{1864,2509,475,1},{2971,541,676,1},{3313,2610,572,1},{491,2456,73,1},{802,408,255,1},{1932,485,244,1},{3505,1101,337,1},{3636,2540,993,1},{1458,930,884,1},{3869,1111,608,1},{2777,2428,455,1},{405,2572,484,1},{901,1930,691,1},{978,1573,249,1},{3055,2967,779,1},{841,1566,656,1},{3214,1343,861,1},{2794,1116,222,1},{858,922,576,1},{2387,1063,776,1},{1989,2693,816,1},{3230,632,483,1},{332,1348,712,1},{1959,1850,950,1}};
    private ArrayList<ImageMarker> MarkerList1 = new ArrayList<ImageMarker>();
    private ArrayList<ImageMarker> MarkerList2 = new ArrayList<ImageMarker>();
    private ArrayList<ImageMarker> MarkerList3D = new ArrayList<ImageMarker>();
    private int[] maxXYZ;
//    private ArrayList<ImageMarker> MarkerList1 = Convert2DTo3D.ArrayToMarkerList(new Matrix(polist1),0,0);
//    private ArrayList<ImageMarker> MarkerList2 = Convert2DTo3D.ArrayToMarkerList(new Matrix(polist2),0,0);
//    boolean tag2 = true;
//    boolean tag1 = true;
    boolean tag2 = false;
    boolean tag1 = false;

    //////////////testdata for NCC

    //输入点对
//    double[][] polist1 = new double[][]{{1714.7351,481.94458,1},{1702.8799,746.5856,1},{1697.2687,1180.755,1},{1685.4966,1283.7231,1},{1256.0372,1053.771,1},{2323.0845,1890.9382,1},{2351.079,2971.8403,1},{496.78162,2928.3013,1},{454.94238,1908.7051,1}};
//
//    double[][] polist2 = new double[][]{{1654.4371,474.12903,1},{1628.8568,732.10114,1},{1592.3121,1169.2343,1},{1582.4728,1266.1536,1},{1166.2509,1052.7257,1},{2571.4243,1859.9949,1},{2613.3745,2912.9946,1},{767.12244,2928.8904,1},{709.17194,1907.3645,1}};

    //角点undownsample
    /*double[][] plist1 = new double[][]{{0.0,205.0,1},{1.0,205.0,1},{551.0,782.0,1},{248.0,1282.0,1},{53.0,1284.0,1},{96.0,1281.0,1},{455.0,1909.0,1},{454.0,1909.0,1},{456.0,1909.0,1},{497.0,2928.0,1},
            {469.0,2903.0,1},{497.0,2929.0,1},{76.0,3554.0,1},{269.0,3511.0,1},{80.0,3552.0,1},{626.0,89.0,1},{626.0,90.0,1},{627.0,89.0,1},{728.0,1305.0,1},{727.0,1305.0,1},
            {719.0,1300.0,1},{869.0,2117.0,1},{855.0,2045.0,1},{922.0,2315.0,1},{843.0,2507.0,1},{998.0,2741.0,1},{959.0,2740.0,1},{641.0,3563.0,1},{826.0,3515.0,1},{988.0,3536.0,1},
            {1190.0,676.0,1},{1191.0,676.0,1},{1190.0,675.0,1},{1697.0,1181.0,1},{1635.0,1180.0,1},{1697.0,1182.0,1},{1220.0,2118.0,1},{1205.0,2235.0,1},{1322.0,2245.0,1},{1220.0,2724.0,1},
            {1193.0,2726.0,1},{1204.0,2617.0,1},{1730.0,3557.0,1},{1676.0,3507.0,1},{1677.0,3507.0,1},{1924.0,251.0,1},{2339.0,465.0,1},{2313.0,25.0,1},{2311.0,1562.0,1},{2341.0,1563.0,1},
            {2311.0,1563.0,1},{1926.0,2047.0,1},{2323.0,1891.0,1},{2324.0,1891.0,1},{2105.0,2938.0,1},{2105.0,2949.0,1},{2107.0,2947.0,1},{1794.0,3493.0,1},{1793.0,3493.0,1},{1794.0,3494.0,1},
            {2529.0,172.0,1},{2528.0,172.0,1},{2529.0,171.0,1},{2739.0,1256.0,1},{2647.0,1559.0,1},{2647.0,1558.0,1},{2767.0,2268.0,1},{2757.0,2263.0,1},{2767.0,2269.0,1},{2622.0,3164.0,1},
            {2622.0,3163.0,1},{2623.0,3164.0,1},{2974.0,3368.0,1},{2457.0,3734.0,1},{2523.0,3768.0,1}};

    double[][] plist2 = new double[][]{{253.0,768.0,1},{253.0,767.0,1},{139.0,778.0,1},{248.0,1290.0,1},{249.0,1290.0,1},{231.0,1271.0,1},{596.0,2310.0,1},{596.0,2309.0,1},{596.0,2313.0,1},{189.0,2936.0,1},
            {188.0,2937.0,1},{185.0,2938.0,1},{129.0,3846.0,1},{129.0,3847.0,1},{313.0,3539.0,1},{1144.0,744.0,1},{720.0,389.0,1},{1143.0,744.0,1},{613.0,1282.0,1},{763.0,1297.0,1},
            {764.0,1297.0,1},{1131.0,2069.0,1},{1155.0,2107.0,1},{1122.0,2110.0,1},{1188.0,2549.0,1},{1167.0,2603.0,1},{1135.0,2548.0,1},{599.0,3522.0,1},{600.0,3522.0,1},{600.0,3521.0,1},
            {1654.0,474.0,1},{1654.0,473.0,1},{1330.0,741.0,1},{1255.0,1177.0,1},{1592.0,1169.0,1},{1592.0,1170.0,1},{1272.0,2278.0,1},{1422.0,2156.0,1},{1268.0,2283.0,1},{1400.0,2597.0,1},
            {1362.0,2688.0,1},{1197.0,2493.0,1},{1731.0,3709.0,1},{1730.0,3709.0,1},{1470.0,3420.0,1},{2115.0,35.0,1},{2210.0,52.0,1},{2114.0,36.0,1},{2116.0,1551.0,1},{2114.0,1551.0,1},
            {2209.0,1436.0,1},{1926.0,1962.0,1},{2188.0,2004.0,1},{1871.0,1969.0,1},{1909.0,2609.0,1},{1908.0,2609.0,1},{2359.0,2899.0,1},{2095.0,3503.0,1},{2124.0,3437.0,1},{2173.0,3506.0,1},
            {2751.0,396.0,1},{2751.0,395.0,1},{2735.0,181.0,1},{2975.0,1183.0,1},{2600.0,1237.0,1},{2599.0,1237.0,1},{2571.0,1860.0,1},{2547.0,2002.0,1},{2553.0,2002.0,1},{2403.0,2888.0,1},
            {2403.0,2899.0,1},{2403.0,2895.0,1},{2388.0,3528.0,1},{2389.0,3528.0,1},{2388.0,3529.0,1}};*/

    //角点downsample
//    double[][] plist1 = new double[][]{{1142.0,504.0,1},{1950.0,1988.0,1},{454.0,1910.0,1},{1712.0,484.0,1},{1704.0,744.0,1},{1196.0,702.0,1},{1360.0,1190.0,1},{1696.0,1182.0,1},{1692.0,1280.0,1},{2738.0,1256.0,1},{2322.0,1890.0,1}};

    double[][] plist1 = new double[][]{{394.0,708.0,1},{394.0,710.0,1},{392.0,708.0,1},{108.0,1216.0,1},{70.0,1284.0,1},{132.0,1234.0,1},{456.0,1910.0,1},{456.0,1908.0,1},{454.0,1910.0,1},{470.0,2902.0,1},
            {496.0,2928.0,1},{512.0,2938.0,1},{78.0,3554.0,1},{78.0,3552.0,1},{76.0,3554.0,1},{1142.0,504.0,1},{1194.0,684.0,1},{1194.0,682.0,1},{726.0,1304.0,1},{720.0,1300.0,1},
            {726.0,1306.0,1},{1012.0,2276.0,1},{862.0,2194.0,1},{1110.0,2312.0,1},{1064.0,2934.0,1},{812.0,2942.0,1},{986.0,2944.0,1},{828.0,3516.0,1},{728.0,3724.0,1},{640.0,3562.0,1},
            {1712.0,484.0,1},{1704.0,744.0,1},{1196.0,702.0,1},{1360.0,1190.0,1},{1696.0,1182.0,1},{1692.0,1280.0,1},{1316.0,2234.0,1},{1310.0,2290.0,1},{1206.0,2234.0,1},{1252.0,2948.0,1},
            {1258.0,2948.0,1},{1218.0,2610.0,1},{1678.0,3506.0,1},{1678.0,3508.0,1},{1730.0,3558.0,1},{2142.0,170.0,1},{1858.0,4.0,1},{2116.0,72.0,1},{1830.0,1570.0,1},{2048.0,1454.0,1},
            {1828.0,1570.0,1},{2322.0,1892.0,1},{1950.0,1988.0,1},{2322.0,1890.0,1},{2330.0,2928.0,1},{2240.0,2934.0,1},{2294.0,2952.0,1},{1794.0,3482.0,1},{1796.0,3482.0,1},{1794.0,3490.0,1},
            {2934.0,372.0,1},{2932.0,372.0,1},{2908.0,32.0,1},{2736.0,1252.0,1},{2738.0,1256.0,1},{2738.0,1252.0,1},{2766.0,2270.0,1},{2766.0,2268.0,1},{2766.0,2274.0,1},{2638.0,2388.0,1},
            {2712.0,2934.0,1},{2636.0,2390.0,1},{2974.0,3368.0,1},{2974.0,3366.0,1},{2836.0,3966.0,1}};

    double[][] plist2 = new double[][]{{140.0,778.0,1},{254.0,768.0,1},{138.0,778.0,1},{246.0,1288.0,1},{248.0,1290.0,1},{146.0,1212.0,1},{596.0,2310.0,1},{570.0,1746.0,1},{596.0,1742.0,1},{162.0,3000.0,1},
        {160.0,3000.0,1},{160.0,2998.0,1},{274.0,3744.0,1},{270.0,3744.0,1},{272.0,3746.0,1},{1084.0,488.0,1},{1084.0,490.0,1},{1144.0,744.0,1},{762.0,1296.0,1},{612.0,1282.0,1},
        {760.0,1296.0,1},{710.0,1908.0,1},{1154.0,2104.0,1},{606.0,2088.0,1},{766.0,2928.0,1},{1186.0,2580.0,1},{782.0,2938.0,1},{604.0,3522.0,1},{604.0,3520.0,1},{602.0,3522.0,1},
        {1654.0,474.0,1},{1654.0,476.0,1},{1628.0,732.0,1},{1256.0,1178.0,1},{1592.0,1170.0,1},{1580.0,1266.0,1},{1364.0,2260.0,1},{1276.0,2156.0,1},{1364.0,2262.0,1},{1228.0,2930.0,1},
        {1394.0,2592.0,1},{1308.0,2504.0,1},{1772.0,3450.0,1},{1760.0,3478.0,1},{1544.0,3544.0,1},{2350.0,0.0,1},{2350.0,2.0,1},{2352.0,0.0,1},{1828.0,1562.0,1},{1828.0,1564.0,1},
        {1830.0,1570.0,1},{2198.0,1962.0,1},{2042.0,1956.0,1},{2216.0,1918.0,1},{1910.0,2610.0,1},{1912.0,2620.0,1},{1910.0,2620.0,1},{2034.0,3456.0,1},{2172.0,3506.0,1},{2104.0,3506.0,1},
        {2974.0,54.0,1},{2974.0,116.0,1},{2734.0,182.0,1},{2600.0,1236.0,1},{2600.0,1234.0,1},{2598.0,1234.0,1},{2570.0,1860.0,1},{2494.0,2060.0,1},{2548.0,2002.0,1},{2556.0,2894.0,1},
        {2556.0,2884.0,1},{2568.0,2884.0,1},{2420.0,3448.0,1},{2392.0,3538.0,1},{2394.0,3538.0,1}};

    boolean flagcorner1 = false;
    boolean flagcorner2 = false;
//    boolean flagcorner1 = true;
//    boolean flagcorner2 = true;
    Convert2DTo3D p2 = new Convert2DTo3D();




    private static String[] PERMISSIONS_STORAGE = {
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.WRITE_EXTERNAL_STORAGE,
            Manifest.permission.CAMERA};
    private static final int REQUEST_PERMISSION_CODE = 1;

    //子线程中实现UI更新
    @SuppressLint("HandlerLeak")
    private Handler uiHandler = new Handler(){
        // 覆写这个方法，接收并处理消息。
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what){
                case 1:
                    Log.v("filesocket_send: ", "Connect with Server successfully");
                    getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
                    System.out.println("------ Upload file successfully!!! -------");
                    popupView.dismiss();
                    break;
            }
        }
    };

    /**
     * 动态加载 openCV4Android 的库
     */
    @Override
    public void onResume()
    {
        super.onResume();
        if (!OpenCVLoader.initDebug()) {
            Log.i("cv", "Internal OpenCV library not found. Using OpenCV Manager for initialization");
        } else {
            Log.i("cv", "OpenCV library found inside package. Using it!");
        }
    }



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
//        setContentView(R.layout.activity_main);
//        imageView = (ImageView) findViewById(R.id.imageview3);

        //MultiDex.install(this);
        myrenderer = new MyRenderer();
        myGLSurfaceView = new MyGLSurfaceView(this);
        setContentView(myGLSurfaceView);
        popupView = new XPopup.Builder(this)
                .dismissOnTouchOutside(false)
                .asLoading("Processing......");
        context = getApplicationContext();




        /*
        testbutton = (Button) findViewById(R.id.testbutton);////用于测试
        testbutton.setOnClickListener(new View.OnClickListener() {
            @RequiresApi(api = Build.VERSION_CODES.KITKAT)
            @Override
            public void onClick(View v) {
                Log.d("TAG","Click test Button");
                try {
                    Fun_Test();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
         */


//        mScaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.OnScaleGestureListener() {
//            private  float scale;
//            private float preScale = 1;//默认前一次缩放比例为1
//
//            @Override
//            public boolean onScale(ScaleGestureDetector detector) {
//                float previousSpan = detector.getPreviousSpan();
//                float currentSpan = detector.getCurrentSpan();
//                if(currentSpan<previousSpan){
//                    //缩小
//                    scale = preScale - (previousSpan-currentSpan)/1000;
//                }else{
//                    //放大
//                    scale = preScale + (currentSpan-previousSpan)/1000;
//                }
//                //缩放view
//                ViewHelper.setScaleX(imageView,scale);// x方向上缩小
//                ViewHelper.setScaleY(imageView,scale);// y方向上缩小
//                return false;
//            }
//
//            @Override
//            public boolean onScaleBegin(ScaleGestureDetector detector) {
//                return true;//返回true才会进入onScale()这个函数
//            }
//
//            @Override
//            public void onScaleEnd(ScaleGestureDetector detector) {
//                preScale = scale;//记录本次缩放比例
//            }
//        });




        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {
            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                ActivityCompat.requestPermissions(this, PERMISSIONS_STORAGE, REQUEST_PERMISSION_CODE);
            }
        }

    }


    /**
     * called when request permission
     * @param requestCode
     * @param permissions
     * @param grantResults
     */
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        switch (requestCode){
            case REQUEST_PERMISSION_CODE: {
                for (int i = 0; i < permissions.length; i++) {
                    Log.i("MainActivity", "申请的权限为：" + permissions[i] + ",申请结果：" + grantResults[i]);
                }
                break;
            }
        }

    }

    public boolean onTouchEvent(MotionEvent event){
        return mScaleGestureDetector.onTouchEvent(event);
    }


    //================新添menu部分======================//
    public boolean onCreateOptionsMenu(Menu menu){
        getMenuInflater().inflate(R.menu.main,menu);
        return true;
    }

    @RequiresApi(api = Build.VERSION_CODES.KITKAT)
    public boolean onOptionsItemSelected(MenuItem item){
        switch (item.getItemId()){
            case R.id.openimage:
                Toast.makeText(this, "Choosing work mode...", Toast.LENGTH_LONG).show();
                openPictureSelectDialog();
                break;
            case R.id.function:
                boolean flag;
                if (isMutiImg) {

                    if (isP1) {
                        flag = !ImageOpened;
                    } else {
                        flag = !ImageOpened2;
                    }

                } else {
                    flag = !ImageOpened;
                }


                if(flag){
                    Toast.makeText(this, "Please load an image first!", Toast.LENGTH_LONG).show();
                } else {
                    chooseFunctionDialog();
                }
                break;
            //case R.id.
        }
        return true;
    }

    void chooseFunctionDialog(){
        Context dialogContext = new ContextThemeWrapper(MainActivity.this,android.R.style.Theme_Light);
        String[] Items = new String[4];
        Items[0] = "Edge Detection";
        Items[1] = "FourAreaLable";
        Items[2] = "HoughCircle";
        Items[3] = "On building..";
        ListAdapter adapter = new ArrayAdapter<String>(dialogContext,android.R.layout.simple_list_item_1,Items);
        AlertDialog.Builder builder = new AlertDialog.Builder(dialogContext);
        builder.setTitle("Functions");
        builder.setSingleChoiceItems(adapter,-1,new DialogInterface.OnClickListener(){
            @RequiresApi(api = Build.VERSION_CODES.KITKAT)
            @Override
            public void onClick(DialogInterface dialog, int which){
                switch (which){
                    case 0:
                        Toast.makeText(MainActivity.this, "edge function..", Toast.LENGTH_LONG).show();
                        Log.d("TAG", "Click EdgeDetect Button");
                        EdgeDetect_Test();
                        break;
                    case 1:
                        Toast.makeText(MainActivity.this, "FourAreaLable function..", Toast.LENGTH_LONG).show();
                        Log.d("TAG", "Click FourAreaLable Button");
                        try {
                            FourAreaLable_Fun();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                        break;
                    case 2:
                        Toast.makeText(MainActivity.this, "HoughCircle function..", Toast.LENGTH_LONG).show();
                        try {

                            Hough_Circle_Fun();//HoughCircle
                           // Circle_Fun();
                            //Hessian_Fun();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                        break;
                    case 3:
                        Toast.makeText(MainActivity.this,"Test Function..",Toast.LENGTH_LONG).show();
                        Log.d("TAG", "Click Test Button");
                        try {
//                            Circle_Fun();
                         //  Test_Fun();
                            testforcorner();
//                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
//                                Convert2Dto3D_Test();
//                            }


                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                        break;
                }
                dialog.dismiss();
            }
        });
        builder.create().show();
    }

    //用于子线程内toast
    public void Toast_in_Thread(final String message){
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Toast.makeText(context, message,Toast.LENGTH_SHORT).show();
            }
        });
    }

    //======================================================//
    void openPictureSelectDialog() {
        Context dialogContext = new ContextThemeWrapper(MainActivity.this, android.R.style.Theme_Light);
        String[] choiceItems = new String[3];
        choiceItems[0] = "camera";
        choiceItems[1] = "album";
        choiceItems[2] = "3D-Reconstruction";
        ListAdapter adapter = new ArrayAdapter<String>(dialogContext, android.R.layout.simple_list_item_1, choiceItems);
        AlertDialog.Builder builder = new AlertDialog.Builder(dialogContext);
        builder.setTitle("Add picture");
        builder.setSingleChoiceItems(adapter, -1, new DialogInterface.OnClickListener() {
            @RequiresApi(api = Build.VERSION_CODES.P)
            @Override
            public void onClick(DialogInterface dialog, int which) {
                switch (which) {
                    case 0:
                        if (isMutiImg) {
                            clear3D_Reconstruction();
                        }
                        checkPermission();
                        ImageOpened = true;
                        break;
                    case 1:
                        if (isMutiImg) {
                            clear3D_Reconstruction();
                        }
                        PickPhotoFromGallery();
                        ImageOpened = true;
                        break;
                    case 2:
                        if (isMutiImg) {
                            clear3D_Reconstruction();
                            if (ImageOpened == true) {
                                ImageOpened = false;
                                clearPreImage();
                            }
                        }
                        Reconstruction3D();
                        isMutiImg = true;
                        //ImageOpened = true;
                        break;
                }
                dialog.dismiss();
            }
        });
        builder.create().show();
    }


    private void Hough_Circle_Fun() throws Exception {

        getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
        popupView.show();

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                Bitmap bitmap = myrenderer.GetBitmap();//从myrenderer获取bitmap
                if (bitmap == null) {
                    Log.v("Test_Fun", "Please load img first!");
                    if (Looper.myLooper() == null) {
                        Looper.prepare();
                    }
                    Toast_in_Thread("Please load image first!");
                    Looper.loop();
                    return;
                }
                Bitmap blurbitmap = ImageFilter.blurBitmap(MainActivity.this,bitmap);//高斯滤波
                System.out.println("Enter here(the gauss finished!!)");
                ArrayList<Point> circles = new ArrayList<>();//存放找到的圆
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
                    try {
                        circles =  HoughCircle.HoughCircle_Fun(blurbitmap);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println("The number of circles:"+circles.size());
                    //Toast.makeText(this, "Circles number:"+circles.size(), Toast.LENGTH_LONG).show();
                    System.out.println("Enter here(the circles have been found!!)");
                }
                Bitmap new_bitmap = Point.DrawCircle(circles,bitmap);
                System.out.println("Enter here(the circles have been drawn!!)");
                //imageView.setImageBitmap(new_bitmap);
                myrenderer.ResetImage(new_bitmap);
                myGLSurfaceView.requestRender();
                System.out.println("Enter here(the bitmap have been updated!!)");
                ImageTools.recycle_fun(bitmap);
                ImageTools.recycle_fun(blurbitmap);
                uiHandler.sendEmptyMessage(1);
            }
        });

        thread.start();
    }



    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)
    private void Circle_Fun() throws Exception {

        getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
        popupView.show();

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                Bitmap bitmap = myrenderer.GetBitmap();//从myrenderer获取bitmap
                if (bitmap == null) {
                    Log.v("Test_Fun", "Please load img first!");
                    if (Looper.myLooper() == null) {
                        Looper.prepare();
                    }
                    Toast_in_Thread("Please load image first!");
                    Looper.loop();
                    return;
                }
            Bitmap blurbitmap = ImageFilter.blurBitmap(MainActivity.this,bitmap);//高斯滤波
            System.out.println("Enter here(the gauss finished!!)");
                /////////////CircleDetect_new/////////////////
                Bitmap new_bitmap = null;
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
                    try {
                        new_bitmap = CircleDetect_Fun(bitmap,blurbitmap);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                //imageView.setImageBitmap(new_bitmap);
            myrenderer.ResetImage(new_bitmap);
            myGLSurfaceView.requestRender();
            System.out.println("Enter here(the bitmap have been updated!!)");
            ImageTools.recycle_fun(bitmap);
            ImageTools.recycle_fun(blurbitmap);
            uiHandler.sendEmptyMessage(1);
            }
        });

        thread.start();
    }


    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)
    private void FourAreaLable_Fun() throws Exception {
        Bitmap bitmap = myrenderer.GetBitmap();//从myrenderer获取bitmap
        if(bitmap == null){
            Log.v("Test_Fun", "Please load img first!");
            if (Looper.myLooper() == null) {
                Looper.prepare();
            }
            Toast.makeText(getContext(), "Please load image first!", Toast.LENGTH_LONG).show();
            Looper.loop();
            return;
        }
        //////////距离变换////////////
        ImgObj_Para imobj = new ImgObj_Para(bitmap);
        imobj.colorToGray2D(bitmap);
        GSDT_Para p = new GSDT_Para();
        int[][] binay_img = ImageTools.myOTSU(imobj.gray_img,imobj.height,imobj.width,256);
        //p.phi = GSDT_Fun(p, imobj.gray_img);
        p.phi = GSDT_Fun(p, binay_img);//////////////////////////////
        float max_value = p.phi[0][0];
        for(int i=0; i<p.phi.length; i++){
            for(int j=0; j<p.phi[0].length; j++){
                //imobj.tar_img[1][i][j] = (int) p.phi[i][j]/255;
                if(p.phi[i][j]>max_value) max_value = p.phi[i][j];
            }
        }
        for(int i=0; i<p.phi.length; i++){
            for(int j=0; j<p.phi[0].length; j++){
                imobj.tar_img[1][i][j] = (int) (p.phi[i][j]/100)*255;
            }
        }
        Bitmap new_bitmap = imobj.gray2DToBitmap(imobj.tar_img,imobj.width,imobj.height);
        myrenderer.ResetImage(new_bitmap);
        myGLSurfaceView.requestRender();
        /////////////用于函数测试/////////////
/*        Mat src = new Mat();//测试opencv
        Mat temp = new Mat();
        Mat dst = new Mat();
        Utils.bitmapToMat(bitmap,src);//把image转化为Mat
        Imgproc.cvtColor(src,temp,Imgproc.COLOR_BGR2GRAY);//这里由于使用的是Imgproc这个模块所有这里要这么写
        Log.i("CV", "image type:" + (temp.type() == CvType.CV_8UC3));
        Imgproc.cvtColor(temp,dst, Imgproc.COLOR_GRAY2BGR);
        Utils.matToBitmap(dst,bitmap);//把mat转化为bitmap
        myrenderer.ResetImage(bitmap);
        myGLSurfaceView.requestRender();
 */
/*        Bitmap blur_bitmap = ImageFilter.blurBitmap(MainActivity.this,bitmap);
        System.out.println("Enter here(the function)");
        //ImgObj_Para iobj = new ImgObj_Para(blur_bitmap);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            bitmap = FourAreaLabel.AreaLabel(blur_bitmap);
        }
        System.out.println("Enter here1");
        myrenderer.ResetImage(bitmap);
        myGLSurfaceView.requestRender();
        Toast.makeText(getContext(), "Have been shown on the screen.", Toast.LENGTH_SHORT).show();
        //imageView.setImageBitmap(bitmap);
        System.out.println("Enter here2");
        bitmap.recycle(); //回收bitmap

 */
    }




    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)
    private void Test_Fun() throws Exception {

        getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
        popupView.show();

        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                Bitmap bitmap = myrenderer.GetBitmap();//从myrenderer获取bitmap
                if (bitmap == null) {
                    Log.v("Test_Fun", "Please load img first!");
                    if (Looper.myLooper() == null) {
                        Looper.prepare();
                    }
                    Toast_in_Thread("Please load image first!");
                    Looper.loop();
                    return;
                }

                /////////////用于函数测试/////////////
                //Bitmap blur_bitmap = ImageFilter.blurBitmap(MainActivity.this,bitmap);blur_
                System.out.println("Enter here(the function)");
                //ImgObj_Para iobj = new ImgObj_Para(blur_bitmap);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                    try {
                        bitmap = HessianMatrixLine.HessianLine(bitmap);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                /*
                Bitmap blurbitmap = ImageFilter.blurBitmap(MainActivity.this,bitmap);//高斯滤波
                /////////////CircleDetect_new/////////////////
                Bitmap new_bitmap = null;
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.KITKAT) {
                   new_bitmap = CircleDetect_Fun(bitmap,blurbitmap);
                }
                 */

                System.out.println("Enter here1");
                myrenderer.ResetImage(bitmap);
                myGLSurfaceView.requestRender();
                Toast_in_Thread("Have been shown on the screen.");
                //imageView.setImageBitmap(bitmap);
                //ImageTools.savePhotoToSDCard(bitmap, Environment.getExternalStorageDirectory().getAbsolutePath() + "/SI_Photo", String.valueOf(System.currentTimeMillis()));
                System.out.println("Enter here2");
                //bitmap.recycle(); //回收bitmap

                uiHandler.sendEmptyMessage(1);

            }
        });

        thread.start();
    }


        private void EdgeDetect_Test(){
        try {
            Bitmap bitmap = myrenderer.GetBitmap();//从myrenderer获取bitmap
            if(bitmap == null){
                Log.v("Test_Fun", "Please load img first!");
                if (Looper.myLooper() == null) {
                    Looper.prepare();
                }
                Toast.makeText(getContext(), "Please load image first!", Toast.LENGTH_LONG).show();
                Looper.loop();
                return;
            }
            Bitmap blur_bitmap = ImageFilter.blurBitmap(MainActivity.this,bitmap);
            //System.out.println("Enter here(the function)");
            ImgObj_Para iobj = new ImgObj_Para(blur_bitmap);
            double dRationHigh=0.84,dRationLow=0.6;///可调
            //double dRationHigh=0.85,dRationLow=0.5;///可调
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                EdgeDetect_fun.Canny_edge(iobj,blur_bitmap,dRationHigh,dRationLow);
            }
            //System.out.println("Enter here1");
            ImageTools.recycle_fun(bitmap);
            ImageTools.recycle_fun(blur_bitmap);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                myrenderer.ResetImage(iobj.gray2DToBitmap(iobj.tar_img,iobj.width,iobj.height));
            }
            // myrenderer.ResetImg(iobj.EdgeImage);
            //imageView.setImageBitmap(iobj.EdgeImage);

            //myrenderer.ResetImg(blur_bitmap);
            //System.out.println("Enter here2");
            myGLSurfaceView.requestRender();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }



    @RequiresApi(api = Build.VERSION_CODES.N)
    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (resultCode == RESULT_OK) {
            switch (requestCode) {
                case TAKE_PHOTO:
                    String status = Environment.getExternalStorageState();//读取SD卡状态
                    if (status.equals(Environment.MEDIA_MOUNTED)) {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                            try {
                                myrenderer.SetPath(currentPhotoPath);
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                        //System.out.println(showPic.getAbsolutePath());


                        //清空工作区marker
                        ArrayList<ImageMarker> temp = myrenderer.getMarkerList();
                        if (temp.size() != 0) {
                            temp.clear();
                            myrenderer.ResetMarkerlist(temp);
                        }


                        myGLSurfaceView.requestRender();
                        if (isMutiImg) {
                            if (isP1) {
                                showimg1 = myrenderer.GetBitmap();
                                img1 = showimg1.copy(Bitmap.Config.ARGB_8888, false);
                                //System.out.println(img1 == null);
                            } else {
                                showimg2 = myrenderer.GetBitmap();
                                img2 = showimg2.copy(Bitmap.Config.ARGB_8888, false);
                                //System.out.println(img2 == null);
                            }
                        }

                        //Bitmap bitmap = BitmapFactory.decodeFile(Environment.getExternalStorageDirectory() + "/image.jpg");
//                        try {
//                            Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(photoURI));
//                            int degree = getBitmapDegree(currentPhotoPath);
//                            System.out.println(degree);
//                            bitmap = rotateBitmapByDegree(bitmap, degree);
//                            Bitmap newBitmap = ImageTools.zoomBitmap(bitmap, bitmap.getWidth() / 5, bitmap.getHeight() / 5);
//                            imageView.setImageBitmap(newBitmap);
//                            ImageTools.savePhotoToSDCard(bitmap, Environment.getExternalStorageDirectory().getAbsolutePath() + "/SI_Photo", String.valueOf(System.currentTimeMillis()));
//                            bitmap.recycle();
//                        }catch (FileNotFoundException e){
//                            e.printStackTrace();
//                        }
                    }
                    break;
                case CHOOSE_PHOTO:
                    ContentResolver resolver = getContentResolver();
                    Uri originalUri = data.getData();
 //                   currentPicturePath = getRealPathFromUri(this,originalUri);
                    String path = originalUri.toString();
                    try {
                        myrenderer.SetPath(path);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }

                    if (isMutiImg) {
                        boolean flag1,flag2;
                        if (isP1 && ImageOpened) {
                            flag1 = false;
                        } else {
                            flag1 = ImageOpened;
                        }
                        if (isP1 && ImageOpened2) {
                            flag2 = false;
                        } else {
                            flag2 = ImageOpened2;
                        }
                        if (flag1 || flag2) {
                            Bitmap temp1 = myrenderer.GetBitmap();
                            Bitmap temp2;
                            if (isP1) {
                                temp2 = img2;
                            } else {
                                temp2 = img1;
                            }
                            if ((temp1.getWidth() != temp2.getWidth()) || (temp1.getHeight() != temp2.getHeight())) {
                                Toast.makeText(getContext(), "Please load images token by the same camera!", Toast.LENGTH_LONG).show();
                                if (isP1) {
                                    if (ImageOpened) {
                                        myrenderer.ResetImage(showimg1,img1);
                                        myrenderer.ResetMarkerlist(MarkerList1);
                                        myGLSurfaceView.requestRender();
                                    } else {
                                        clearPreImage();
                                    }

                                } else {
                                    if (ImageOpened2) {
                                        myrenderer.ResetImage(showimg2,img2);
                                        myrenderer.ResetMarkerlist(MarkerList2);
                                        myGLSurfaceView.requestRender();
                                    } else {
                                        clearPreImage();
                                    }

                                }

                                return;

                            }
                        }

                        if (isP1) {
                            Log.v("loadImage", "load Image1");
                            showimg1 = myrenderer.GetBitmap();
                            img1 = showimg1.copy(Bitmap.Config.ARGB_8888, false);
                            MarkerList1.clear();
                            ImageOpened = true;
                        } else {
                            Log.v("loadImage", "load Image2");
                            showimg2 = myrenderer.GetBitmap();
                            img2 = showimg2.copy(Bitmap.Config.ARGB_8888, false);
                            MarkerList2.clear();
                            ImageOpened2 = true;
                        }
                    } else {
                        //清空工作区marker
                        ArrayList<ImageMarker> temp = myrenderer.getMarkerList();
                        if (temp.size() != 0) {
                            temp.clear();
                            myrenderer.ResetMarkerlist(temp);
                        }
                        myGLSurfaceView.requestRender();
                    }




                    /*
                    try {
                        Bitmap photo = MediaStore.Images.Media.getBitmap(resolver, originalUri);
                        int degree = getBitmapDegree(currentPicturePath);
                        if (photo != null) {
                            Bitmap smallBitmap = ImageTools.zoomBitmap(photo, photo.getWidth() / 5, photo.getHeight() / 5);
                            smallBitmap = rotateBitmapByDegree(smallBitmap, degree);
                            photo.recycle();
                            imageView.setImageBitmap(smallBitmap);
                        }
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }*/
                    break;
                default:
                    break;
            }
        }
    }

    private void TakePhoto() {
        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        // Ensure that there's a camera activity to handle the intent
        if (intent.resolveActivity(getPackageManager()) != null) {
            // Create the File where the photo should go
            ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
            File photoFile = null;
            //            String photoFilePath = null;
            try {
                photoFile = createImageFile();
            } catch (IOException ex) {
                // Error occurred while creating the File
            }
            currentPhotoPath = photoFile.getAbsolutePath();
            if (photoFile != null) {
                photoURI = FileProvider.getUriForFile(MainActivity.this,
                        "com.example.si.provider",
                        photoFile);
                intent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
                startActivityForResult(intent, TAKE_PHOTO);
                Log.v("Camera", "Here we are");
            }
        }
    }


    private void PickPhotoFromGallery() {
        Intent intent = new Intent();
        intent.setType("image/*");
        intent.setAction(Intent.ACTION_GET_CONTENT);
        startActivityForResult(intent, CHOOSE_PHOTO);
    }

    @RequiresApi(api = Build.VERSION_CODES.P)
    private void Reconstruction3D() {

        img_switch = new Button(this);
        img_switch.setText("P1");
        img_switch.setAllCaps(false);
        img_switch.setTextColor(Color.BLACK);
        FrameLayout.LayoutParams params_img_switch = new FrameLayout.LayoutParams(230, 120);
        params_img_switch.gravity = Gravity.TOP | Gravity.LEFT;
        params_img_switch.setMargins(50,20,0,0);
        this.addContentView(img_switch,params_img_switch);//
        img_switch.setVisibility(View.VISIBLE);

        loadImage = new Button(this);
        loadImage.setText("Load");
        loadImage.setAllCaps(false);
        loadImage.setTextColor(Color.BLACK);
        FrameLayout.LayoutParams params_loadImage = new FrameLayout.LayoutParams(230, 120);
        params_loadImage.gravity = Gravity.TOP | Gravity.LEFT;
        params_loadImage.setMargins(300,20,0,0);
        this.addContentView(loadImage,params_loadImage);//
        loadImage.setVisibility(View.VISIBLE);

        select_points = new Button(this);
        select_points.setText("Point");
        select_points.setAllCaps(false);
        select_points.setTextColor(Color.BLACK);
        FrameLayout.LayoutParams params_select_points = new FrameLayout.LayoutParams(230, 120);
        params_select_points.gravity = Gravity.TOP | Gravity.LEFT;
//        params_select_points.setMargins(550,20,0,0);
        params_select_points.setMargins(300,20,0,0);
        this.addContentView(select_points,params_select_points);//
        select_points.setVisibility(View.GONE);

        finished = new Button(this);
        finished.setText("Finish");
        finished.setAllCaps(false);
        finished.setTextColor(Color.BLACK);
        FrameLayout.LayoutParams params_finished = new FrameLayout.LayoutParams(230, 120);
        params_finished.gravity = Gravity.TOP | Gravity.LEFT;
//        params_finished.setMargins(800,20,0,0);
        params_finished.setMargins(550,20,0,0);
        this.addContentView(finished,params_finished);//
        finished.setVisibility(View.GONE);

        Process = new Button(this);
        Process.setText("Process");
        Process.setAllCaps(false);
        Process.setTextColor(Color.BLACK);
        FrameLayout.LayoutParams params_Process = new FrameLayout.LayoutParams(230, 120);
        params_Process.gravity = Gravity.TOP | Gravity.LEFT;
        params_Process.setMargins(550,20,0,0);
        this.addContentView(Process,params_Process);//
        Process.setVisibility(View.VISIBLE);

        dimension_switch = new Button(this);
        dimension_switch.setText("P1");
        dimension_switch.setAllCaps(false);
        dimension_switch.setTextColor(Color.BLACK);
        FrameLayout.LayoutParams params_dimension_switch = new FrameLayout.LayoutParams(230, 120);
        params_dimension_switch.gravity = Gravity.TOP | Gravity.LEFT;
        params_dimension_switch.setMargins(50,20,0,0);
        this.addContentView(dimension_switch,params_dimension_switch);//
        dimension_switch.setVisibility(View.GONE);

        img_switch.setOnClickListener(new Button.OnClickListener() {
            @Override
            public void onClick(View v) {

                clearSelect_points();
                if (isP1){
//                    MarkerList1 = myrenderer.getMarkerList();
                    ////////////////////////
                    if (tag1) {

                        for (int i = 0; i < polist1.length; i++) {
                            /*double temp = polist1[i][0];
                            polist1[i][0] = polist1[i][1];
                            polist1[i][1] = img1.getHeight()-temp;*/
                            polist1[i][0] += img1.getWidth()/2.0;
                            polist1[i][1] += img1.getHeight()/2.0;
                        }

                        MarkerList1 = Convert2DTo3D.ArrayToMarkerList(new Matrix(polist1),0,0,3);
                        int a = 0;
                        for (ImageMarker imageMarker:MarkerList1) {
                            System.out.println(a+" "+imageMarker.x);
                            System.out.println(a+" "+imageMarker.y);
                            a++;
                        }
                        tag1 = false;
                    } else {
                        if (flagcorner1) {
                            MarkerList1 = Convert2DTo3D.ArrayToMarkerList(new Matrix(plist1),0,0,3);
                        } else {
                            MarkerList1 = myrenderer.getMarkerList();
                            out.println("*** Markerlist1 = "+MarkerList1.size()+" ***");
                        }
                    }
                    ////////////////////////
                    //img1 = myrenderer.GetBackupBitmap();
                    showimg1 = myrenderer.GetBitmap();
                    Log.v("img_switch", "Change to P2");
                    isP1 = !isP1;
                    img_switch.setText("P2");
                    //functionMenu(isFinished2);

                    //display points
                    myrenderer.ResetMarkerlist(MarkerList2);
                    out.println("*** Markerlist2 = "+MarkerList2.size()+" ***");
                    //System.out.println("MarkerList2 is empty: "+ MarkerList2.isEmpty());

                    if (ImageOpened2) {
                        myrenderer.ResetImage(showimg2,img2);


                        myGLSurfaceView.requestRender();
                    } else {
                        if (ImageOpened) {
                            clearPreImage();
                        }
                        //return;
                    }

                } else {
//                    MarkerList2 = myrenderer.getMarkerList();
                    ////////////////////////
                    if (tag2) {

                        for (int i = 0; i < polist2.length; i++) {
                            /*double temp = polist2[i][0];
                            polist2[i][0] = polist2[i][1];
                            polist2[i][1] = img2.getHeight()-temp;*/
                            polist2[i][0] += img2.getWidth()/2.0;
                            polist2[i][1] += img2.getHeight()/2.0;
                        }
                        out.println(">>>>>>>>>>>>>>>>>>>>>"+polist2[0][0]);
                        MarkerList2 = Convert2DTo3D.ArrayToMarkerList(new Matrix(polist2),0,0, 3);
                        int a = 0;
                        for (ImageMarker imageMarker:MarkerList2) {
                            System.out.println(a+" "+imageMarker.x);
                            System.out.println(a+" "+imageMarker.y);
                            a++;
                        }
                        tag2 = false;
                    } else {
                        if (flagcorner2) {
                            MarkerList2 = Convert2DTo3D.ArrayToMarkerList(new Matrix(plist2),0,0, 3);
                        } else {
                            MarkerList2 = myrenderer.getMarkerList();
                            out.println("*** Markerlist2 = "+MarkerList2.size()+" ***");
                        }

                    }
                    ////////////////////////
                    //img2 = myrenderer.GetBackupBitmap();
                    showimg2 = myrenderer.GetBitmap();
                    Log.v("img_switch", "Change to P1");
                    isP1 = !isP1;
                    img_switch.setText("P1");
                    //functionMenu(isFinished1);

                    //display points
                    myrenderer.ResetMarkerlist(MarkerList1);
                    out.println("*** Markerlist1 = "+MarkerList1.size()+" ***");

                    if (ImageOpened) {
                        myrenderer.ResetImage(showimg1,img1);

                        myGLSurfaceView.requestRender();
                    } else {
                        if (ImageOpened2) {
                            clearPreImage();
                        }
                        //return;
                    }

                }
            }
        });

        //loadimage
        loadImage.setOnClickListener(new Button.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.v("load image", "Image loading!");
                Loadimage(v);
            }
        });

        select_points.setOnClickListener(new Button.OnClickListener() {
            @Override
            public void onClick(View v) {
                //测试解方程函数
//                double[][] array = {{0,2,7},{1,1,1},{2,5,3}};
//                double[][] array2 = {{32},{7},{24}};
//                System.out.println(array[0][0]+","+array[1][0]+","+array[2][0]);
//                System.out.println(array[0][1]+","+array[1][1]+","+array[2][1]);
//                System.out.println(array2[0][0]+","+array2[1][0]+","+array2[2][0]);
//                double[] result = Convert2DTo3D.linerFunction3_3(new Matrix(array),new Matrix(array2));
//
//                System.out.println("方程的解为：");
//                System.out.println(result[0]+","+result[1]+","+result[2]);
               // ORBTest(MarkerList1, MarkerList2);//ORB提取匹配点
                Log.v("Select_points", "Point selecting!");
                if (isP1) {
                    if (img1 == null) {
                        Toast.makeText(context, "Please load a image first", Toast.LENGTH_SHORT).show();
                        return;
                    }
                } else {
                    if (img2 == null) {
                        Toast.makeText(context, "Please load a image first", Toast.LENGTH_SHORT).show();
                        return;
                    }
                }

                SelectPoint(v);


            }
        });

        //finished 旧版
        /*finished.setOnClickListener(new Button.OnClickListener() {
            @Override
            public void onClick(View v) {

                Log.v("Finished", "Finish point select of the image!");
                boolean flag = false;
                if (isP1) {
                    if (img1 == null) {
                        Toast.makeText(context, "Please load a image first", Toast.LENGTH_SHORT).show();
                        return;
                    }
                } else {
                    if (img2 == null) {
                        Toast.makeText(context, "Please load a image first", Toast.LENGTH_SHORT).show();
                        return;
                    }
                }

                clearSelect_points();
             //   Mat m = new Mat();
//                ORBTest(MarkerList1, MarkerList2);//ORB提取匹配点

                if (isP1){
                    MarkerList1 = myrenderer.getMarkerList();
                    int pointnum1 = MarkerList1.size();
                    int pointnum2 = MarkerList2.size();
                    System.out.println("flag = "+flag);

                    if (!isProcessed) {
                        flag = pointnum1 > 8;
                    } else {
                        flag = pointnum1 > 0;
                    }
                    if (flag) {
                        if (isFinished2) {
                            isFinished1 = true;
                            functionMenu(true);

//                            if (pointnum1 == pointnum2) {
//                                isFinished1 = true;
//                                functionMenu(true);
//                            } else {
//                                Toast.makeText(getContext(), "Point number is insufficient, please add more!", Toast.LENGTH_SHORT).show();
//                            }
                        } else {
                            if (pointnum1 >= pointnum2) {
                                isFinished1 = true;
                                functionMenu(true);
                                myrenderer.setMarkerNum(MarkerList1.size());
                            } else {
                                Toast.makeText(getContext(), "Point number is insufficient, please add more!", Toast.LENGTH_SHORT).show();
                            }
                        }
                    } else {
                        if (!isProcessed) {
                            Toast.makeText(getContext(), "Point number must be more than 8!", Toast.LENGTH_SHORT).show();
                        } else {
                            Toast.makeText(getContext(), "Point number must be more than 0!", Toast.LENGTH_SHORT).show();
                        }

                    }


                } else {
                    MarkerList2 = myrenderer.getMarkerList();
                    int pointnum1 = MarkerList1.size();
                    int pointnum2 = MarkerList2.size();
                    System.out.println("flag = "+flag);
                    System.out.println("MarkerList1.isEmpty() = "+MarkerList1.isEmpty());
                    System.out.println("MarkerList2.isEmpty() = "+MarkerList2.isEmpty());

                    if (!isProcessed) {
                        flag = pointnum2 > 8;
                    } else {
                        flag = pointnum2 > 0;
                    }
                    if (flag) {
                        if (isFinished1) {
                            isFinished2 = true;
                            functionMenu(true);

//                            if (pointnum1 == pointnum2) {
//                                isFinished2 = true;
//                                functionMenu(true);
//                            } else {
//                                Toast.makeText(getContext(), "Point number is insufficient, please add more!", Toast.LENGTH_SHORT).show();
//                            }
                        } else {
                            if (pointnum1 <= pointnum2) {
                                isFinished2 = true;
                                functionMenu(true);
                                myrenderer.setMarkerNum(MarkerList2.size());
                            } else {
                                Toast.makeText(getContext(), "Point number is insufficient, please add more!", Toast.LENGTH_SHORT).show();
                            }
                        }
                    } else {
                        if (!isProcessed) {
                            Toast.makeText(getContext(), "Point number must be more than 8!", Toast.LENGTH_SHORT).show();
                        } else {
                            Toast.makeText(getContext(), "Point number must be more than 0!", Toast.LENGTH_SHORT).show();
                        }
                    }

                }


                if (isFinished1 & isFinished2) {
                    img_switch.setVisibility(View.GONE);
                    Process.setVisibility(View.VISIBLE);
                }
            }
        });*/

        //finished 20201020版
        finished.setOnClickListener(new Button.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.v("Finished", "Finish point select of the image!");
                boolean flag = false;
                if (isP1) {
                    if (img1 == null) {
                        Toast.makeText(context, "Please load a image first", Toast.LENGTH_SHORT).show();
                        return;
                    }
                } else {
                    if (img2 == null) {
                        Toast.makeText(context, "Please load a image first", Toast.LENGTH_SHORT).show();
                        return;
                    }
                }

                clearSelect_points();
                isFinished1 = true;
                isFinished2 = true;
                ifDeletePointPair = false;
                setLayoutAfterFinish();
            }
        });

        //Process
        Process.setOnClickListener(new Button.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.v("Process", "Do 2D to 3D reconstruction!");
                //图一点集为MarkerList1
                //图二点集为MarkerList2

                /*if (!isProcessed) {
                    isProcessed = true;


                    //获取特征点并匹配
                    pointsGetAndMatch();

                    //检验是否可以进行三维重建
                    if (MarkerList1.size() < 9 || MarkerList2.size() < 9) {
                        Toast.makeText(getContext(), "Point number is insufficient!", Toast.LENGTH_SHORT).show();

                    ///////////////////2Dto3D/////////////////////
                    //原点调整为图像中心
                    for (int i = 0; i < Po_list1.length;i++) {
                        Po_list1[i][0] -= img1.getWidth()/2f;
                        Po_list1[i][1] -= img1.getHeight()/2f;
                        Po_list2[i][0] -= img2.getWidth()/2f;
                        Po_list2[i][1] -= img2.getHeight()/2f;

                    }
                    Convert2DTo3D_new p = new Convert2DTo3D_new();
//                    Convert2DTo3D p = new Convert2DTo3D();
                    p.MyMobileModel = Convert2DTo3D_new.MobileModel.MIX2;
//                    p.MyMobileModel = Convert2DTo3D.MobileModel.MIX2;
 //                   p.Convert2DTo3D_Fun(Po_list1, Po_list2,p.MyMobileModel);
//                    p.Convert2DTo3D_Fun(Po_list1, Po_list2, p.MyMobileModel);
                    //计算相机外参矩阵
                    p.OpticalCenter[0] = img1.getWidth()/2;
                    p.OpticalCenter[1] = img1.getHeight()/2;
    /*                    p.OpticalCenter[0] = 0;
                    p.OpticalCenter[1] = 0;*/
/*                    DataBuilder dataBuilder = new DataBuilder(1,false);//新添用于测试不同误差级别//////
                    boolean flag = false;//非自标定
                    try {
                        flag = p.Convert2DTo3D_Fun_init(Po_list1, Po_list2, dataBuilder.F, FfList);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
//                    boolean flag = p.Convert2DTo3D_Fun_new(Po_list1, Po_list2,dataBuilder,FfList);//非自标定
//                    boolean flag = p.Convert2DTo3D_Fun(Po_list1, Po_list2, p.MyMobileModel);//自标定
                    if (!flag) {
                        clear3D_Reconstruction();
                        clearPreImage();
                        return;
                    }

                    //图像点对的三维重建
                    convert2DTo3D();

                    //提示运行完成
                    Toast.makeText(getContext(), "The external parameter matrix of camera is calculated!", Toast.LENGTH_SHORT).show();
                    //初始化下一阶段界面按钮
                    initiateForReconstruction3D();
                } else {
                    isProcessed2 = !isProcessed2;

                    //目标点投射到三维
                    if (isP1) {
                        myrenderer.ResetMarkerlist(MarkerList1);
                    } else {
                        myrenderer.ResetMarkerlist(MarkerList2);
                    }
                    myGLSurfaceView.requestRender();
                    initiateForReconstruction3D();
                }*/
                if (isFinished1 && isFinished2) {
                    try {
                        Processing();
                        initializeLayout3D();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
//                    initiateForReconstruction3D();
                } else {
                    //ORB提取匹配点
                    ORBTest(img1,img2);
                    myGLSurfaceView.requestRender();
                    select_points.setVisibility(View.VISIBLE);
                    finished.setVisibility(View.VISIBLE);
                    Process.setVisibility(View.GONE);
                    loadImage.setVisibility(View.GONE);
                }


                //改变marker颜色可以直接对相应ImageMarker对象的type属性进行修改，深蓝色为3号，type支持1-8
            }
        });

        //dimension switch
        /*dimension_switch.setOnClickListener(new Button.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.v("dimension switch", "Image loading!");
                if (ifDraw3D) {
                    ifDraw3D = false;
                    setLayoutTo2D();
                } else {
                    ifDraw3D = true;
                    setLayoutTo3D();
                }
                myGLSurfaceView.requestRender();
            }
        });*/

    }

    private void setLayoutAfterFinish() {
        select_points.setVisibility(View.GONE);
        finished.setVisibility(View.GONE);
        FrameLayout.LayoutParams params_Process = new FrameLayout.LayoutParams(230, 120);
        params_Process.setMargins(300,20,0,0);
        Process.setLayoutParams(params_Process);
        Process.setVisibility(View.VISIBLE);
    }

    private void setLayoutTo2D() {

        img_switch.setVisibility(View.VISIBLE);
        dimension_switch.setText("2D");

        if (isP1) {
            myrenderer.ResetMarkerlist(MarkerList1);
            myrenderer.ResetImage(showimg1,img1);
        } else {
            myrenderer.ResetMarkerlist(MarkerList2);
            myrenderer.ResetImage(showimg2,img2);
        }

    }

    private void setLayoutTo3D() {

        img_switch.setVisibility(View.GONE);
        dimension_switch.setText("3D");

        myrenderer.ResetMarkerlist(MarkerList3D);
        myrenderer.ResetIfDraw3D(ifDraw3D, maxXYZ);
    }

    private void initializeLayout3D() {
        FrameLayout.LayoutParams params_img_switch = new FrameLayout.LayoutParams(230, 120);
        params_img_switch.gravity = Gravity.TOP | Gravity.LEFT;
        params_img_switch.setMargins(300,20,0,0);
        img_switch.setLayoutParams(params_img_switch);
        img_switch.setVisibility(View.VISIBLE);

        Process.setVisibility(View.GONE);

//        dimension_switch.setVisibility(View.VISIBLE);
    }


    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR1)
    private void Processing() throws Exception {

        getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,
                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
        popupView.show();

        Thread thread = new Thread(new Runnable() {
            @RequiresApi(api = Build.VERSION_CODES.N)
            @Override
            public void run() {
                if (!ImageOpened || !ImageOpened2) {
                    Log.v("MainActivity","Need two pictures!");
                    Toast_in_Thread("Need two pictures!");
                    uiHandler.sendEmptyMessage(1);
                    return;
                }

                if (!isProcessed) {
                    isProcessed = true;

                    //获取特征点并匹配
                    pointsGetAndMatch();

                    if (isP1) {
                        myrenderer.ResetMarkerlist(MarkerList1);
                    } else {
                        myrenderer.ResetMarkerlist(MarkerList2);
                    }
                    myGLSurfaceView.requestRender();

                    //检验是否可以进行三维重建
                    if (MarkerList1.size() < 9 || MarkerList2.size() < 9) {
                        //Toast.makeText(getContext(), "Point number is insufficient!", Toast.LENGTH_SHORT).show();
                        Log.v("MainActivity", "Point number is insufficient!");
                        Toast_in_Thread("Point number is insufficient!");
                        uiHandler.sendEmptyMessage(1);
                        return;
                    }

                    //图像点对的三维重建
//                    convert2DTo3D();

                    //提示运行完成
                    Toast_in_Thread("The external parameter matrix of camera is calculated!!");
                    //初始化下一阶段界面按钮
//                    initiateForReconstruction3D();
                } else {
                    isProcessed2 = !isProcessed2;

                    //目标点投射到三维
                    if (isP1) {
                        myrenderer.ResetMarkerlist(MarkerList1);
                    } else {
                        myrenderer.ResetMarkerlist(MarkerList2);
                    }
                    myGLSurfaceView.requestRender();
//                    initiateForReconstruction3D();
                }
                uiHandler.sendEmptyMessage(1);
            }
        });

        thread.start();
    }

    private void pointsGetAndMatch() {
        //ORB提取匹配点
//        ORBTest(img1,img2);
        //区域ORB提取匹配点
//        regionAutoORB();

//        out.println("markerlist1: "+MarkerList1.size());

//        precisePointPairsSelect(Math.max(img1.getHeight(), img1.getWidth())/10);
//        out.println("treshold = "+Math.max(img1.getHeight(), img1.getWidth())/10);

        //RANSAC筛选
//        MatOfPoint2f Po1_Mat = p2.ArrayToMatOfPoint2f(MarkerListToArray(MarkerList1));
//        MatOfPoint2f Po2_Mat = p2.ArrayToMatOfPoint2f(MarkerListToArray(MarkerList2));
//        Mat mask = new Mat();
//        Calib3d.findFundamentalMat(Po1_Mat, Po2_Mat, Calib3d.FM_RANSAC, 5f, 0.995, mask);
//
//        for (int i = 0; i < MarkerList1.size(); i++) {
//            if (mask.get(i,0)[0] == 0) {
//                out.println("mask.get(i,0)[0] = "+mask.get(i,0)[0]);
//                MarkerList1.remove(i);
//                MarkerList2.remove(i);
//                i--;
//
//            }
//        }
//        Toast.makeText(getContext(), "Feature Points have been obtained!", Toast.LENGTH_SHORT).show();
        out.println("markerlist1: "+MarkerList1.size());

        //点对粗略单应矩阵计算
        double[][] Po_list1 = MarkerListToArray(MarkerList1);
        double[][] Po_list2 = MarkerListToArray(MarkerList2);
        out.println("markerlist1: "+MarkerList1.size());

        if (!flagcorner1 && !flagcorner2) {
            //计算单应矩阵
            p2.Convert2DTo2D_func(Po_list1, Po_list2);
            MarkerList1.addAll(p2.Point2Dto2D1);
            MarkerList2.addAll(p2.Point2Dto2D2);
            //myGLSurfaceView.requestRender();

        }

        //获取角点
        setCornerPoints();
        out.println("markerlist1: "+MarkerList1.size());

        //角点匹配
//                    int[] matchList = p2.Convert2DTo2D_func2(MarkerList1,MarkerList2,img1,img2);
        int[][] matchList = p2.Convert2DTo2D_func02(MarkerList1,MarkerList2,img1,img2);

        //根据匹配结果重新生成markerlist
        ArrayList<ImageMarker> newTemp1 = new ArrayList<ImageMarker>();
        ArrayList<ImageMarker> newTemp2 = new ArrayList<ImageMarker>();
        for (int i = 0; i < matchList.length; i++) {
            //单向匹配
//                            if (matchList[i] == -1) {
//                                continue;
//                            } else {
//                                ImageMarker imageMarker1 = new ImageMarker();
//                                ImageMarker imageMarker2 = new ImageMarker();
//                                //1To2
//                                imageMarker1 = MarkerList1.get(i);
//                                imageMarker2 = MarkerList2.get(matchList[i]);
//                                //2To1
////                                imageMarker1 = MarkerList1.get(matchList[i]);
////                                imageMarker2 = MarkerList2.get(i);
//                                imageMarker1.type = 4;
//                                imageMarker2.type = 4;
//                                System.out.println("(x1,y1): ("+imageMarker1.x+","+imageMarker1.y+")---(x2,y2): ("+imageMarker2.x+","+imageMarker2.y+")");
//                                newTemp1.add(imageMarker1);
//                                newTemp2.add(imageMarker2);
//                            }

            ImageMarker imageMarker1 = new ImageMarker();
            ImageMarker imageMarker2 = new ImageMarker();
            imageMarker1 = MarkerList1.get(matchList[i][0]);
            imageMarker2 = MarkerList2.get(matchList[i][1]);
            imageMarker1.type = 3;
            imageMarker2.type = 3;
            System.out.println("(x1,y1): ("+imageMarker1.x+","+imageMarker1.y+")---(x2,y2): ("+imageMarker2.x+","+imageMarker2.y+")");
            newTemp1.add(imageMarker1);
            newTemp2.add(imageMarker2);
//            out.println("newTemp1.size = "+newTemp1.size()+"---newTemp2.size = "+newTemp2.size());

        }
        out.println("newTemp1.size = "+newTemp1.size()+"---newTemp2.size = "+newTemp2.size());
        MarkerList1.clear();
        MarkerList2.clear();
        MarkerList1.addAll(newTemp1);
        MarkerList2.addAll(newTemp2);/**/
    }

    public void precisePointPairsSelect(int threshold) { //threshold = max(image.getWidth(), image.getHeight())
        boolean flag = false; //ArrayList<ImageMarker> MarkerList1, ArrayList<ImageMarker> MarkerList2,
        Set<Integer> res;
        ArrayList<ImageMarker> tempMarkerList1 = new ArrayList<ImageMarker>();
        ArrayList<ImageMarker> tempMarkerList2 = new ArrayList<ImageMarker>();

        //初始化三个低误差点
        res = p2.randPerm(MarkerList1.size(), 3);
        while (!flag) {
            double[][] Po_list1 = new double[3][2];
            double[][] Po_list2 = new double[3][2];
            for (int i = 0; i < 3; i++) {
                ImageMarker imageMarker1 = MarkerList1.get((int) res.toArray()[i]);
                tempMarkerList1.add(imageMarker1);

                ImageMarker imageMarker2 = MarkerList2.get((int) res.toArray()[i]);
                tempMarkerList2.add(imageMarker2);
            }
            Po_list1 = MarkerListToArray(tempMarkerList1);
            Po_list2 = MarkerListToArray(tempMarkerList2);
            p2.Convert2DTo2D_func(Po_list1, Po_list2);
            out.println("maxdis2 = "+p2.maxdis2);
            if (p2.maxdis2 <= threshold) {
                flag = true;
            } else {
                res = p2.randPerm(MarkerList1.size(), 3);
            }
        }

        //逐个增加低误差点对
        for (int i = 0; i < MarkerList1.size(); i++) {
            if (i == (int)res.toArray()[0] || i == (int)res.toArray()[1] || i == (int)res.toArray()[2]) {
                continue;
            }
            ImageMarker imageMarker1 = MarkerList1.get(i);
            tempMarkerList1.add(imageMarker1);
            ImageMarker imageMarker2 = MarkerList2.get(i);
            tempMarkerList2.add(imageMarker2);
            double[][] Po_list1 = MarkerListToArray(tempMarkerList1);
            double[][] Po_list2 = MarkerListToArray(tempMarkerList2);
            p2.Convert2DTo2D_func(Po_list1, Po_list2);
            out.println("maxdis2 = "+p2.maxdis2);

            if (p2.maxdis2 > threshold) {
                tempMarkerList1.remove(imageMarker1);
                tempMarkerList2.remove(imageMarker2);
            }
        }

        MarkerList1.clear();
        MarkerList1.addAll(tempMarkerList1);
        MarkerList2.clear();
        MarkerList2.addAll(tempMarkerList2);
    }

    @RequiresApi(api = Build.VERSION_CODES.N)
    private void convert2DTo3D() {
        //更新点集数组
        double[][] Po_list1 = MarkerListToArray(MarkerList1);
        double[][] Po_list2 = MarkerListToArray(MarkerList2);

        ///////////////////2Dto3D/////////////////////
        //原点调整为图像中心
        for (int i = 0; i < Po_list1.length;i++) {
            Po_list1[i][0] -= img1.getWidth()/2f;
            Po_list1[i][1] -= img1.getHeight()/2f;
            Po_list2[i][0] -= img2.getWidth()/2f;
            Po_list2[i][1] -= img2.getHeight()/2f;

        }
        Convert2DTo3D_new p = new Convert2DTo3D_new();
//        Convert2DTo3D p = new Convert2DTo3D();
//        p.MyMobileModel = Convert2DTo3D_new.MobileModel.MIX2;
//        p.MyMobileModel = Convert2DTo3D.MobileModel.MIX2;
//        p.Convert2DTo3D_Fun(Po_list1, Po_list2,p.MyMobileModel);
//        p.Convert2DTo3D_Fun(Po_list1, Po_list2, p.MyMobileModel);
        //计算相机外参矩阵
        p.OpticalCenter[0] = img1.getWidth()/2;
        p.OpticalCenter[1] = img1.getHeight()/2;
//      p.OpticalCenter[0] = 0;
//      p.OpticalCenter[1] = 0;
        DataBuilder dataBuilder = new DataBuilder(1,false);//新添用于测试不同误差级别//////
        boolean flag = false;//非自标定
        try {
            flag = p.Convert2DTo3D_Fun_init(Po_list1, Po_list2, dataBuilder.F, FfList);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (!flag) {
            clear3D_Reconstruction();
            clearPreImage();
            return;
        }

        p.Point3DTo2D(p.X_3D);
        MarkerList1.addAll(p.Point3Dto2D1);
        MarkerList2.addAll(p.Point3Dto2D2);
        myGLSurfaceView.requestRender();
        ///////////////////////////////////


//                    ArrayList<ImageMarker> Point3D = ArrayToMarkerList(p.X_3D);//保存三维坐标
//                    for(ImageMarker im: Point3D){
//                        Log.d("TestConvert3DFun","=========x:"+im.x+","+"y:"+im.y+","+"z:"+im.z);
//                    }
        //                   p.CalculateError(p.X_3D, Po_list1, Po_list2);


        //测试LM算法/////////////////////////////
//                    Matrix Po1 = p.Point2DToHomogeneous(Po_list1);//n*3矩阵
//                    Matrix Po2 = p.Point2DToHomogeneous(Po_list2);//n*3矩阵
//                    BundleAdjustment_LM.LM(Po1, Po2, p.P1, p.P2_Selected, p.X_3D);

        ///////////////测试极线/////////////////////////

        showimg2 = p.DrawLine(showimg2, p.EpiLines2_Para);
        showimg1 = p.DrawLine(showimg1, p.EpiLines1_Para);

        if (isP1) {
            myrenderer.ResetImage(showimg1);
        } else {
            myrenderer.ResetImage(showimg2);
        }
        myGLSurfaceView.requestRender();

        ifDraw3D = true;
        displayPoints3D(p, ifDraw3D);

        ////////////////////////////////////////////////////
        /*ArrayList<ImageMarker> temp = new ArrayList<>();
        ImageMarker marker1 = new ImageMarker(200,1000,400,3);
        temp.add(marker1);
        ImageMarker marker2 = new ImageMarker(0,1000,400,3);
        temp.add(marker2);
        ImageMarker marker3 = new ImageMarker(200,0,400,3);
        temp.add(marker3);
        ImageMarker marker4 = new ImageMarker(0,0,0,3);
        temp.add(marker4);

        int[] max = new int[]{200,1000,400};

        myrenderer.ResetMarkerlist(temp);
        myrenderer.ResetIfDraw3D(true, max);
        myGLSurfaceView.requestRender();*/
        ///////////////////////////////////////////////////
    }

    private void regionAutoORB() {
        int[] R = new int[2];
        ArrayList<ImageMarker> tempList1 = new ArrayList<ImageMarker>();
        ArrayList<ImageMarker> tempList2 = new ArrayList<ImageMarker>();
        Bitmap temp1, temp2;

        //获取合适的分割倍数
        float stepx, stepy;
        stepx = 7f; //  ?????
        stepy = 7f;
        R[0] = round(img1.getWidth() / stepx);
        R[1] = round(img1.getHeight() / stepy);
        System.out.println("R[0] = "+R[0]);
        System.out.println("R[1] = "+R[1]);

        if (MarkerList1 != null) {
            //工作区准备
            MarkerList1.clear();
            MarkerList2.clear();
        }


        //区域中心定位图像块
        for (int center_x = R[0]; center_x < img1.getWidth(); center_x += 2*R[0]+1) {
            for (int center_y = R[1]; center_y < img1.getHeight(); center_y += 2*R[1]+1) {
                System.out.println("center_x = "+center_x);
                System.out.println("center_y = "+center_y);
                //AutoORB获取匹配点对
                temp1 = getSmallImageBlock(img1,center_x,center_y,R[0],R[1]);
                temp2 = getSmallImageBlock(img2,center_x,center_y,R[0],R[1]);
                if (temp1 == null || temp2 == null) {
                    continue;
                }

                ORBTest(temp1, temp2, center_x-R[0], center_y-R[1]);

                if (MarkerList1 != null) {
                    tempList1.addAll(MarkerList1);
                    tempList2.addAll(MarkerList2);
                    MarkerList1.clear();
                    MarkerList2.clear();
                }

            }
        }

        MarkerList1.addAll(tempList1);
        MarkerList2.addAll(tempList2);
    }

    /**
     * 获取图像中 [x,x+Rx] [y,y+Ry] 区域的图像块，若区域超出图像范围返回null
     * @param image 原图像
     * @param x 左上角横坐标
     * @param y 左上角纵坐标
     * @param Rx 横向宽度
     * @param Ry 纵向高度
     * @return 截取的图像块
     */
    private Bitmap getSmallImageBlock(Bitmap image, int x, int y,int Rx, int Ry) {
        int xfrom = x - Rx;
        int xto = x + Rx;
        int yfrom = y - Ry;
        int yto = y+Ry;
        int xlen = xto - xfrom + 1;
        int ylen = yto - yfrom + 1;

        if (xto >= image.getWidth() || yto >= image.getHeight() || xfrom < 0 || yfrom < 0) {
            if (xto - xlen / 2 <= image.getWidth() || yto - ylen / 2 <= image.getHeight()) {
                xto = image.getWidth();
                yto = image.getHeight();
                xlen = xto - xfrom + 1;
                ylen = yto - yfrom + 1;
            } else {
                return null;
            }
        }
//        System.out.println("xfrom = "+xfrom);
//        System.out.println("xto = "+xto);
//        System.out.println("yfrom = "+yfrom);
//        System.out.println("yto = "+yto);

//        int color;
        Bitmap myBitmap = null;
        myBitmap = Bitmap.createBitmap( xlen, ylen, Bitmap.Config.ARGB_8888 );
        for (int w = 0; w < xlen; w++) {
            for (int h = 0; h < ylen; h++) {
//                    color = image.getPixel(w,h);
                myBitmap.setPixel(w, h, image.getPixel(xfrom+w,yfrom+h));
            }
        }

        return myBitmap;

}

    private void displayPoints3D(Convert2DTo3D_new p, boolean ifDraw3D) {
        MarkerList3D = p.FeaturePoints3D;
        maxXYZ = p.maxXYZ;
        myrenderer.ResetMarkerlist(p.FeaturePoints3D);
        myrenderer.ResetIfDraw3D(ifDraw3D, p.maxXYZ);
        myGLSurfaceView.requestRender();
    }

    ///////////////////////////////
    private void testforcorner() {

        //获取图一角点
//        myrenderer.ResetImage(img1);
        ArrayList<ImageMarker> temp1 = myrenderer.getMarkerList();
        if (temp1.size() == 0) {
            temp1.clear();
        }
        temp1 = myrenderer.globalImageCornerDetect2();
        System.out.println("temp.size() = "+temp1.size());

//        for (ImageMarker imageMarker:temp1) {
//            out.println("{"+imageMarker.x+","+imageMarker.y+","+"1},");
//        }

//        //获取图二角点
//        myrenderer.ResetImage(img2);
//        ArrayList<ImageMarker> temp2 = new ArrayList<>();
//        temp2 = myrenderer.globalImageCornerDetect();
//        System.out.println("temp.size() = "+temp2.size());

        myrenderer.ResetMarkerlist(temp1);
        myGLSurfaceView.requestRender();

        /*double[][] array = new double[][]{{7.5,6.2,3},{6,0,-3},{0,6,-1}};
        Matrix A = new Matrix(array);
        Matrix b = new Matrix(3,1);
        b.set(0,0,79.09);
        b.set(1,0,9.6);
        b.set(2,0,12.2);*/


        /*double[][] array = new double[][]{{5,-2,7,1},{3,1,-2,-3},{0,4,3,7.5},{2,3.4,0,-6.7}};
        Matrix A = new Matrix(array);
        Matrix b = new Matrix(4,1);
        b.set(0,0,50.3);
        b.set(1,0,-7.9);
        b.set(2,0,43.2);
        b.set(3,0,5.84);
        double[] result = new double[4];
        Matrix Ab = new Matrix(4,5);
        Ab.setMatrix(0,3,0,3,A);
        Ab.setMatrix(0,3,4,4,b.times(-1));*/

        /*double[][] array = new double[][]{{-4,0,0,1},{-4,-3,2,1},{0,-2,0,1},{-3,-2,1,1}};
        Matrix A = new Matrix(array);
        Matrix b = new Matrix(4,1);
        b.set(0,0,0);
        b.set(1,0,0);
        b.set(2,0,0);
        b.set(3,0,0);
        double[] result = new double[4];
        Matrix Ab = new Matrix(4,5);
        Ab.setMatrix(0,3,0,3,A);
        Ab.setMatrix(0,3,4,4,b.times(-1));*/

//        result = A.solve(b).getColumnPackedCopy();
//        result = Convert2DTo3D.linerFunction3_3(A,b);
        /*System.out.println("result[0] = "+result[0]);
        System.out.println("result[1] = "+result[1]);
        System.out.println("result[2] = "+result[2]);
        System.out.println("result[3] = "+result[3]);*/
        //System.out.println("result[4] = "+result[4]);

    }

    ///////////////////////////////

    private void ORBTest(Bitmap img1, Bitmap img2){
        Mat srcr = new Mat();
        Mat tempr = new Mat();
        Mat srcl = new Mat();
        Mat templ = new Mat();
        Mat MatdescriptorR = new Mat();
        Mat MatdescriptorL = new Mat();
        MatOfKeyPoint keypointsR = new MatOfKeyPoint();
        MatOfKeyPoint keypointsL = new MatOfKeyPoint();
        MatOfDMatch matches = new MatOfDMatch();
//        Bitmap imageR = BitmapFactory.decodeResource(this.getResources(),R.drawable.rr);
//        Bitmap imageL = BitmapFactory.decodeResource(this.getResources(),R.drawable.ll);

        Bitmap imageL = img1;
        Bitmap imageR = img2;
        Utils.bitmapToMat(imageR, srcr);//把image转化为Mat
        Utils.bitmapToMat(imageL, srcl);//把image转化为Mat
        Imgproc.cvtColor(srcr,tempr, Imgproc.COLOR_RGBA2RGB);
        Imgproc.cvtColor(srcl,templ, Imgproc.COLOR_RGBA2RGB);
        FeatureDetector detectorR = FeatureDetector.create(FeatureDetector.DYNAMIC_ORB);
        FeatureDetector detectorL = FeatureDetector.create(FeatureDetector.DYNAMIC_ORB);
        //检测特征点
        detectorR.detect(tempr, keypointsR);
        KeyPoint[] po = keypointsL.toArray();
        detectorL.detect(templ, keypointsL);
        /*Features2d.drawKeypoints(tempr,keypointsR,out,new Scalar(255, 0, 0), Features2d.DRAW_RICH_KEYPOINTS);
        Utils.matToBitmap(out, imageR);//把mat转化为bitmap

        imageView.setImageBitmap(imageR);*/

        //计算描述子
        DescriptorExtractor descriptorR = DescriptorExtractor.create(DescriptorExtractor.OPPONENT_ORB);
        DescriptorExtractor descriptorL = DescriptorExtractor.create(DescriptorExtractor.OPPONENT_ORB);
        descriptorR.compute(srcr,keypointsR,MatdescriptorR);
        descriptorL.compute(srcl,keypointsL,MatdescriptorL);
        // FlannBasedMatcher descriptormatcher = FlannBasedMatcher.create();
        DescriptorMatcher descriptormatcher = DescriptorMatcher.create(DescriptorMatcher.BRUTEFORCE_HAMMING);
        descriptormatcher.match(MatdescriptorL,MatdescriptorR,matches);
        System.out.println("............."+matches.cols()+","+matches.rows());
        //-- Quick calculation of max and min distances between keypoints


        double max_dist = 0; double min_dist = 100;
        for( int i = 0; i < MatdescriptorL.rows(); i++ ) {
            double dist = matches.toArray()[i].distance;
            if( dist < min_dist ) min_dist = dist;
            if( dist > max_dist ) max_dist = dist;
        }


        System.out.println("-- Max dist : "+ max_dist );
        System.out.println("-- Min dist : "+ min_dist );
        MatOfDMatch good_matches = new MatOfDMatch();
        for( int i = 0; i < MatdescriptorL.rows(); i++ ) {
            if( matches.toArray()[i].distance <= StrictMath.max(2f*min_dist, 20) ) {
                good_matches.push_back( matches.row(i));
            }
        }
        System.out.println("............."+good_matches.cols()+","+good_matches.rows());
        DMatch[] matchItem = good_matches.toArray();
        System.out.println("....@@@@@@@@@@...."+MarkerList1.isEmpty());
        System.out.println("%%!!!!!!!!!!!!!!!!!!%%% MarkerList Length : "+ MarkerList1.size()+"," + MarkerList2.size());
        for(int i=0; i<good_matches.rows(); i++){
//            System.out.println("....@@@@@@@@@@...."+matchItem.length);
            MarkerList1.add(new ImageMarker((float) keypointsL.toList().get(matchItem[i].queryIdx).pt.x, (float)keypointsL.toList().get(matchItem[i].queryIdx).pt.y, 0,3));
            MarkerList2.add(new ImageMarker((float) keypointsR.toList().get(matchItem[i].trainIdx).pt.x, (float)keypointsR.toList().get(matchItem[i].trainIdx).pt.y, 0,3));
            Log.d("Mainactivity",i+":"+good_matches.toList().get(i));
            Log.d("LImage",i+":("+keypointsL.toList().get(matchItem[i].queryIdx).pt.x+","+keypointsL.toList().get(matchItem[i].queryIdx).pt.y);
            Log.d("RImage",i+":("+keypointsR.toList().get(matchItem[i].trainIdx).pt.x+","+keypointsR.toList().get(matchItem[i].trainIdx).pt.y);
            Log.d("RImage",MarkerList1.get(i).x+","+MarkerList1.get(i).y);
        }
        System.out.println("%%%%%%%%%%%%%%%%% MarkerList Length : "+ MarkerList1.size()+"," + MarkerList2.size());
//        myGLSurfaceView.requestRender();



//        Bitmap outbmp = drawMatches(srcl,keypointsL,srcr,keypointsR,good_matches,false);

        //Features2d.drawMatches(srcl,keypointsL,srcr,keypointsR,matches,out);
        //  Utils.matToBitmap(out, imageR);//把mat转化为bitmap
        // Bitmap matchbitmap=Bitmap.createScaledBitmap(imageR, imageL.getWidth(),  imageR.getHeight(), false);
//        imageView.setImageBitmap(outbmp);
        srcr.release();
        srcl.release();
        templ.release();
        tempr.release();
        MatdescriptorR.release();
        MatdescriptorL.release();
        if (MarkerList1.size() != 0 || MarkerList1 != null) {
            ifDeletePointPair = true;
        }
    }

    private void ORBTest(Bitmap img1, Bitmap img2, int offsetX, int offsetY){
        Mat srcr = new Mat();
        Mat tempr = new Mat();
        Mat srcl = new Mat();
        Mat templ = new Mat();
        Mat MatdescriptorR = new Mat();
        Mat MatdescriptorL = new Mat();
        MatOfKeyPoint keypointsR = new MatOfKeyPoint();
        MatOfKeyPoint keypointsL = new MatOfKeyPoint();
        MatOfDMatch matches = new MatOfDMatch();
//        Bitmap imageR = BitmapFactory.decodeResource(this.getResources(),R.drawable.rr);
//        Bitmap imageL = BitmapFactory.decodeResource(this.getResources(),R.drawable.ll);

        Bitmap imageL = img1;
        Bitmap imageR = img2;
        Utils.bitmapToMat(imageR, srcr);//把image转化为Mat
        Utils.bitmapToMat(imageL, srcl);//把image转化为Mat
        Imgproc.cvtColor(srcr,tempr, Imgproc.COLOR_RGBA2RGB);
        Imgproc.cvtColor(srcl,templ, Imgproc.COLOR_RGBA2RGB);
        FeatureDetector detectorR = FeatureDetector.create(FeatureDetector.DYNAMIC_ORB);
        FeatureDetector detectorL = FeatureDetector.create(FeatureDetector.DYNAMIC_ORB);
        //检测特征点
        detectorR.detect(tempr, keypointsR);
        KeyPoint[] po = keypointsL.toArray();
        detectorL.detect(templ, keypointsL);
        /*Features2d.drawKeypoints(tempr,keypointsR,out,new Scalar(255, 0, 0), Features2d.DRAW_RICH_KEYPOINTS);
        Utils.matToBitmap(out, imageR);//把mat转化为bitmap

        imageView.setImageBitmap(imageR);*/

        //计算描述子
        DescriptorExtractor descriptorR = DescriptorExtractor.create(DescriptorExtractor.OPPONENT_ORB);
        DescriptorExtractor descriptorL = DescriptorExtractor.create(DescriptorExtractor.OPPONENT_ORB);
        descriptorR.compute(srcr,keypointsR,MatdescriptorR);
        descriptorL.compute(srcl,keypointsL,MatdescriptorL);
        // FlannBasedMatcher descriptormatcher = FlannBasedMatcher.create();
        DescriptorMatcher descriptormatcher = DescriptorMatcher.create(DescriptorMatcher.BRUTEFORCE_HAMMING);
        descriptormatcher.match(MatdescriptorL,MatdescriptorR,matches);
        System.out.println("............."+matches.cols()+","+matches.rows());
        //-- Quick calculation of max and min distances between keypoints


        double max_dist = 0; double min_dist = 100;
        for( int i = 0; i < MatdescriptorL.rows(); i++ ) {
            double dist = matches.toArray()[i].distance;
            if( dist < min_dist ) min_dist = dist;
            if( dist > max_dist ) max_dist = dist;
        }


        System.out.println("-- Max dist : "+ max_dist );
        System.out.println("-- Min dist : "+ min_dist );
        MatOfDMatch good_matches = new MatOfDMatch();
        for( int i = 0; i < MatdescriptorL.rows(); i++ ) {
            if( matches.toArray()[i].distance <= StrictMath.max(2f*min_dist, 20) ) {
                good_matches.push_back( matches.row(i));
            }
        }
        System.out.println("............."+good_matches.cols()+","+good_matches.rows());
        DMatch[] matchItem = good_matches.toArray();
        System.out.println("....@@@@@@@@@@...."+MarkerList1.isEmpty());
        System.out.println("%%!!!!!!!!!!!!!!!!!!%%% MarkerList Length : "+ MarkerList1.size()+"," + MarkerList2.size());
        for(int i=0; i<good_matches.rows(); i++){
//            System.out.println("....@@@@@@@@@@...."+matchItem.length);
            MarkerList1.add(new ImageMarker((float) keypointsL.toList().get(matchItem[i].queryIdx).pt.x + offsetX, (float)keypointsL.toList().get(matchItem[i].queryIdx).pt.y + offsetY, 0,3));
            MarkerList2.add(new ImageMarker((float) keypointsR.toList().get(matchItem[i].trainIdx).pt.x + offsetX, (float)keypointsR.toList().get(matchItem[i].trainIdx).pt.y + offsetY, 0,3));
            Log.d("Mainactivity",i+":"+good_matches.toList().get(i));
            Log.d("LImage",i+":("+(keypointsL.toList().get(matchItem[i].queryIdx).pt.x + offsetX)+","+(keypointsL.toList().get(matchItem[i].queryIdx).pt.y + offsetY)+")");
            Log.d("RImage",i+":("+(keypointsR.toList().get(matchItem[i].trainIdx).pt.x + offsetX)+","+(keypointsR.toList().get(matchItem[i].trainIdx).pt.y + offsetY)+")");
            Log.d("RImage",MarkerList1.get(i).x+","+MarkerList1.get(i).y);
        }
        System.out.println("%%%%%%%%%%%%%%%%% MarkerList Length : "+ MarkerList1.size()+"," + MarkerList2.size());
//        myGLSurfaceView.requestRender();



//        Bitmap outbmp = drawMatches(srcl,keypointsL,srcr,keypointsR,good_matches,false);

        //Features2d.drawMatches(srcl,keypointsL,srcr,keypointsR,matches,out);
        //  Utils.matToBitmap(out, imageR);//把mat转化为bitmap
        // Bitmap matchbitmap=Bitmap.createScaledBitmap(imageR, imageL.getWidth(),  imageR.getHeight(), false);
//        imageView.setImageBitmap(outbmp);
        srcr.release();
        srcl.release();
        templ.release();
        tempr.release();
        MatdescriptorR.release();
        MatdescriptorL.release();
    }


    /**
     * 可以画出匹配点
     * @param img1
     * @param key1
     * @param img2
     * @param key2
     * @param matches
     * @param imageOnly
     * @return
     */
    static Bitmap drawMatches(Mat img1, MatOfKeyPoint key1, Mat img2, MatOfKeyPoint key2, MatOfDMatch matches, boolean imageOnly) {
        Mat out = new Mat();
        Mat im1 = new Mat();
        Mat im2 = new Mat();
        Imgproc.cvtColor(img1, im1, Imgproc.COLOR_BGR2RGB);
        Imgproc.cvtColor(img2, im2, Imgproc.COLOR_BGR2RGB);
        if (imageOnly) {
            MatOfDMatch emptyMatch = new MatOfDMatch();
            MatOfKeyPoint emptyKey1 = new MatOfKeyPoint();
            MatOfKeyPoint emptyKey2 = new MatOfKeyPoint();
            Features2d.drawMatches(im1, emptyKey1, im2, emptyKey2, emptyMatch, out);
        } else {
            Features2d.drawMatches(im1, key1, im2, key2, matches, out);
        }
        System.out.println(out.cols()+","+out.rows());
        Bitmap bmp = Bitmap.createBitmap(out.cols(), out.rows(), Bitmap.Config.ARGB_8888);
        Imgproc.cvtColor(out, out, Imgproc.COLOR_BGR2RGB);
        Utils.matToBitmap(out, bmp);//把mat转化为bitmap
        return bmp;
    }


    /**
     * 测试外参矩阵的计算以及恢复三维坐标
     *
     */

    @RequiresApi(api = Build.VERSION_CODES.N)
    private void Convert2Dto3D_Test() throws InterruptedException {
        Convert2DTo3D_new p = new Convert2DTo3D_new();
        p.MyMobileModel = Convert2DTo3D_new.MobileModel.MIX2;
//        p.MyMobileModel = Convert2DTo3D.MobileModel.HUAWEI;
//        Matrix F0 = new Matrix(new double[][]{{0.0,9.765625E-8,0,0},{2.70548366E-4,0.0,1.50015625},{0.0,-1.73205081,0.0}});
        int num = 100;
        for(int it=0; it<10; it++){
            DataBuilder dataBuilder = new DataBuilder(num, false);

            out.println("++++++++++++++++扰动为"+0+"时的2d投影点坐标+++++++++++++++");
            p.Convert2DTo3D_Fun_init(dataBuilder.PoList1, dataBuilder.PoList2, dataBuilder.F, FfList);
            for(int pp=0; pp<dataBuilder.PoList1.length; pp++){
               out.println("第"+pp+"个点的初始坐标为List1：" + dataBuilder.PoList1[pp][0]+","+dataBuilder.PoList1[pp][1]+","+ dataBuilder.PoList1[pp][2]);
               out.println("第"+pp+"个点的初始坐标为List2：" + dataBuilder.PoList2[pp][0]+","+dataBuilder.PoList2[pp][1]+","+ dataBuilder.PoList2[pp][2]);
            }
            for(int i=0; i<=9; i++){
                dataBuilder.AddGuassNoise(0,0.5f*(i+1));
                out.println("++++++++++++++++扰动为"+0.5f*(i+1)+"时的2d投影点坐标+++++++++++++++");
                for(int pp=0; pp<dataBuilder.PoList1.length; pp++){
                    out.println("第"+pp+"个点的真实坐标为List1：" + dataBuilder.PoList1_noise[pp][0]+","+dataBuilder.PoList1_noise[pp][1]+","+ dataBuilder.PoList1_noise[pp][2]);
                    out.println("第"+pp+"个点的真实坐标为List2：" + dataBuilder.PoList2_noise[pp][0]+","+dataBuilder.PoList2_noise[pp][1]+","+ dataBuilder.PoList2_noise[pp][2]);
                }
                p.Convert2DTo3D_Fun_init(dataBuilder.PoList1_noise, dataBuilder.PoList2_noise, dataBuilder.F, FfList);
            }
        }

        double[][] error = new double[11][2];
        for(int j=0; j<FfList.size(); j++){
            error[j%11][0] += FfList.get(j)[0];
            error[j%11][1] += FfList.get(j)[1];
        }
        for(int j=0; j<11; j++){
            error[j][0] /= 11;
            error[j][1] /= 11;
        }


        out.println("FfList的长度为:"+error.length);
        for(int j=0; j<error.length; j++){
            out.println(error[j][0]+",");
        }
        out.println("=====================================f");
        for(int j=0; j<error.length; j++){
            out.println(error[j][1]+",");
        }

//        p.Convert2DTo3D_Fun_new(dataBuilder.PoList1, dataBuilder.PoList2, dataBuilder);
/*        p.Point3DTo2D(p.X_3D);
        System.out.println("==============MainActivity所得三维点坐标==================");
        for (int j=0; j<p.X_3D.getRowDimension(); j++){
            out.println(j+"点的值：" + p.X_3D.get(j,0)+","+p.X_3D.get(j,1)+ ","+p.X_3D.get(j,2)+ ","+p.X_3D.get(j,3));
        }*/

        //double[] error = p.CalculateError(p.X_3D,Po_list2);
    }




    /**
     * function for the Load button
     *
     * @param v the button: Laod
     */
    private void Loadimage(View v) {

        new XPopup.Builder(this)
                .atView(v)  // 依附于所点击的View，内部会自动判断在上方或者下方显示
                .asAttachList(new String[]{"Camera", "Album"},

                        new int[]{},
                        new OnSelectListener() {
                            @Override
                            public void onSelect(int position, String text) {

                                switch (text) {

                                    case "Camera":
                                        //拍照获取图片
                                        clearSelect_points();
                                        if (isP1){
                                            Log.v("loadImage", "load Image1");
                                            //functionMenu(isFinished1);
                                            checkPermission();
                                            MarkerList1.clear();
                                            ImageOpened = true;

                                        } else {
                                            Log.v("loadImage", "load Image2");
                                            //functionMenu(isFinished2);
                                            checkPermission();
                                            MarkerList2.clear();
                                            ImageOpened2 = true;

                                        }
                                        break;

                                    case "Album":
                                        //相册读取图片
                                        clearSelect_points();
                                        PickPhotoFromGallery();

                                        break;

                                }
                            }
                        })
                .show();
    }

    /**
     * function for the Load button
     *
     * @param v the button: Point
     */
    private void SelectPoint(View v) {

        new XPopup.Builder(this)
                .atView(v)  // 依附于所点击的View，内部会自动判断在上方或者下方显示

                .asAttachList(new String[]{"Refinement add", "General add", "Auto ORB","Delete", "Exit point", "NCC match"},


                        new int[]{},
                        new OnSelectListener() {
                            @Override
                            public void onSelect(int position, String text) {

                                switch (text) {

                                    case "Refinement add":
                                        //Harris角点检测矫正
                                        ifPoint = true;
                                        ifDelete = false;
                                        Pointing(true);

                                        break;

                                    case "General add":
                                        //无矫正
                                        ifPoint = true;
                                        ifDelete = false;
                                        Pointing(false);

                                        break;

                                    case "Auto ORB":
                                        ORBTest(img1, img2); //ORB提取匹配点
                                        myGLSurfaceView.requestRender();
                                        Toast.makeText(getContext(), "Feature Points have been obtained!", Toast.LENGTH_SHORT).show();
                                        ifPoint = true;
                                        ifDelete = false;
                                        Pointing(true);

                                        break;

                                    case "Delete":
                                        //删除点
                                        ifPoint = false;
                                        ifDelete = true;
                                        Pointing(false);

                                        break;
                                    case "Exit point":
                                        //退出点操作模式
                                        clearSelect_points();

                                        break;

                                    case "NCC match":
                                        //角点获取
                                        setCornerPoints();

                                        break;

                                }
                            }
                        })
                .show();
    }

    private void setCornerPoints() {
//        flagcorner1 = true;
//        flagcorner2 = true;

        //获取图一角点
        myrenderer.ResetImage(img1,img1);
//        myrenderer.ResetMarkerlist(MarkerList1);
        ArrayList<ImageMarker> temp1 = new ArrayList<ImageMarker>();
        myrenderer.ResetMarkerlist(temp1);
        temp1 = myrenderer.globalImageCornerDetect2();
        System.out.println("temp1.size() = "+temp1.size());

//        for (ImageMarker imageMarker:temp1) {
//            out.println("{"+imageMarker.x+","+imageMarker.y+","+"1},");
//        }
        MarkerList1.clear();
        MarkerList1.addAll(temp1);
        out.println(MarkerList1.size());
        out.println(MarkerList2.size());

//        //获取图二角点
        myrenderer.ResetImage(img2,img2);
//        myrenderer.ResetMarkerlist(MarkerList2);
        ArrayList<ImageMarker> temp2 = new ArrayList<ImageMarker>();
        myrenderer.ResetMarkerlist(temp2);
        temp2 = myrenderer.globalImageCornerDetect2();
        System.out.println("temp2.size() = "+temp2.size());

        MarkerList2.clear();
        MarkerList2.addAll(temp2);
        out.println("MarkerList1: "+MarkerList1.size());
        out.println("MarkerList2: "+MarkerList2.size());

        if (isP1) {
            myrenderer.ResetImage(img1,img1);
            myrenderer.ResetMarkerlist(MarkerList1);
        } else {
            myrenderer.ResetImage(img2,img2);
            myrenderer.ResetMarkerlist(MarkerList2);
        }
        myGLSurfaceView.requestRender();

    }

    private void Pointing(boolean ifRefine) {
        myrenderer.setIfRefine(ifRefine);
        System.out.println("here 111112222");
        if (ifPoint) {
            select_points.setTextColor(Color.BLUE);
            System.out.println("here 111112222");
        }
        if (ifDelete) {
            select_points.setTextColor(Color.RED);

        }
        if (!ifPoint && !ifDelete) {
            select_points.setTextColor(Color.BLACK);
        }
    }


    private void functionMenu (boolean isfinished) {
        if (isfinished) {

            loadImage.setVisibility(View.GONE);
//            select_points.setVisibility(View.GONE);
//            finished.setVisibility(View.GONE);
        } else {
            loadImage.setVisibility(View.VISIBLE);
//            select_points.setVisibility(View.VISIBLE);
//            finished.setVisibility(View.VISIBLE);
        }
    }

    private void clearSelect_points () {
        ifPoint = false;
        ifDelete = false;
        myrenderer.setIfRefine(false);
        select_points.setTextColor(Color.BLACK);
    }

    @RequiresApi(api = Build.VERSION_CODES.KITKAT)
    private void clearPreImage() {
        Bitmap temp = myrenderer.GetBitmap();
        if (temp == null) {
            return;
        }
        int width = temp.getWidth();
        int height  = temp.getHeight();
        Bitmap myBitmap = Bitmap.createBitmap( width, height, Bitmap.Config.ARGB_8888 );
        int color;
        color = Color.argb(1, 1, 1, 1);
        //GLES30.glClearColor(121f / 255f, 134f / 255f, 203f / 255f, 1.0f);//浅紫

        myBitmap.eraseColor(color);
        myrenderer.ResetImage(myBitmap);
        myGLSurfaceView.requestRender();
    }

    //
    private void clear3D_Reconstruction() {
        img1.recycle();
        img2.recycle();
        img1 = null;
        img2 = null;
        showimg1.recycle();
        showimg2.recycle();
        showimg1 = null;
        showimg2 = null;
        MarkerList1.clear();
        MarkerList2.clear();
        isP1 = false;
        ifPoint = false;
        isFinished1 = false;
        isFinished2 = false;
        isMutiImg = false;
        ImageOpened = false;
        ImageOpened2 = false;
        isProcessed = false;
        isProcessed2 = false;
        img_switch.setVisibility(View.GONE);
        loadImage.setVisibility(View.GONE);
//        select_points.setVisibility(View.GONE);
//        finished.setVisibility(View.GONE);
        Process.setVisibility(View.GONE);

        myrenderer.ResetMarkerlist(MarkerList1);
        myrenderer.ResetImage(showimg1,img1);
        myGLSurfaceView.requestRender();
    }

    //private void resetButtonAfterProcess() {}

    private void interestPointsTo3D() {}

    private void initiateForReconstruction3D() {

//        MarkerList1.clear();
//        MarkerList2.clear();
//        if (isP1) {
//            myrenderer.ResetMarkerlist(MarkerList1);
//        } else {
//            myrenderer.ResetMarkerlist(MarkerList2);
//        }
//
//        myrenderer.setMarkerNum(0);
//        myGLSurfaceView.requestRender();

//        isFinished1 = false;
//        isFinished2 = false;
        //isProcessed = false;

        Process.setVisibility(View.GONE);
        loadImage.setVisibility(View.GONE);
        img_switch.setVisibility(View.VISIBLE);

        /*FrameLayout.LayoutParams params_select_points = new FrameLayout.LayoutParams(230, 120);
        params_select_points.setMargins(300,20,0,0);
        select_points.setLayoutParams(params_select_points);//
        select_points.setVisibility(View.VISIBLE);

        FrameLayout.LayoutParams params_finished = new FrameLayout.LayoutParams(230, 120);
        params_finished.setMargins(550,20,0,0);
        finished.setLayoutParams(params_finished);//
        finished.setVisibility(View.VISIBLE);*/

    }

/*
    private String getImageFilePath() {
        String mCaptureDir = "/storage/emulated/0/C3/cameraPhoto";
        File dir = new File(mCaptureDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        String mCapturePath = mCaptureDir + "/" + "Photo_" + System.currentTimeMillis() + ".jpg";
        return mCapturePath;
    }

 */

    private File createImageFile() throws IOException {
        // Create an image file name
        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
        String imageFileName = "JPEG_" + timeStamp + "_";
        File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
        File image = File.createTempFile(
                imageFileName,  /* prefix */
                ".jpg",         /* suffix */
                storageDir      /* directory */
        );

        // Save a file: path for use with ACTION_VIEW intents
        //currentPhotoPath = image.getAbsolutePath();
        return image;
    }

    /*
     * 获取图片的旋转角度
     *
     * @param path 图片绝对路径
     * @return 图片的旋转角度
     */
    /*
    public static int getBitmapDegree(String path) {
        int degree = 0;
        try {
            // 从指定路径下读取图片，并获取其EXIF信息
            ExifInterface exifInterface = new ExifInterface(path);
            // 获取图片的旋转信息
            int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
            Log.v("TAG", "原图被旋转角度： ========== " + orientation );
            switch (orientation) {
                case ExifInterface.ORIENTATION_ROTATE_90:
                    degree = 90;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_180:
                    degree = 180;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_270:
                    degree = 270;
                    break;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return degree;
    }
    /**
     * 将图片按照指定的角度进行旋转
     *
     * @param bitmap 需要旋转的图片
     * @param degree 指定的旋转角度
     * @return 旋转后的图片
     */
    /*
    public static Bitmap rotateBitmapByDegree(Bitmap bitmap, int degree) {
        // 根据旋转角度，生成旋转矩阵
        Matrix matrix = new Matrix();
        matrix.postRotate(degree);
        // 将原始图片按照旋转矩阵进行旋转，并得到新的图片
        Bitmap newBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
        if (bitmap != null && !bitmap.isRecycled()) {
            bitmap.recycle();
        }
        return newBitmap;
    }
    */


    /////////////////////////////////////
    private void checkPermission() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE}, 0);
        } else {
            TakePhoto();
        }
    }
    /**
     * 根据图片的Uri获取图片的绝对路径。@uri 图片的uri
     * @return 如果Uri对应的图片存在,那么返回该图片的绝对路径,否则返回null
     */
    public static String getRealPathFromUri(Context context, Uri uri) {
        if(context == null || uri == null) {
            return null;
        }
        if("file".equalsIgnoreCase(uri.getScheme())) {
            return getRealPathFromUri_Byfile(context,uri);
        } else if("content".equalsIgnoreCase(uri.getScheme())) {
            return getRealPathFromUri_Api11To18(context,uri);
        }
        return getRealPathFromUri_AboveApi19(context, uri);
    }

    //针对图片URI格式为Uri:: file:///storage/emulated/0/DCIM/Camera/IMG_20170613_132837.jpg
    private static String getRealPathFromUri_Byfile(Context context,Uri uri){
        String uri2Str = uri.toString();
        String filePath = uri2Str.substring(uri2Str.indexOf(":") + 3);
        return filePath;
    }

    /**
     * 适配api19以上,根据uri获取图片的绝对路径
     */
    @SuppressLint("NewApi")
    private static String getRealPathFromUri_AboveApi19(Context context, Uri uri) {
        String filePath = null;
        String wholeID = null;

        wholeID = DocumentsContract.getDocumentId(uri);

        // 使用':'分割
        String id = wholeID.split(":")[1];

        String[] projection = { MediaStore.Images.Media.DATA };
        String selection = MediaStore.Images.Media._ID + "=?";
        String[] selectionArgs = { id };

        Cursor cursor = context.getContentResolver().query(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, projection,
                selection, selectionArgs, null);
        int columnIndex = cursor.getColumnIndex(projection[0]);

        if (cursor.moveToFirst()) {
            filePath = cursor.getString(columnIndex);
        }
        cursor.close();
        return filePath;
    }

    /**
     * //适配api11-api18,根据uri获取图片的绝对路径。
     * 针对图片URI格式为Uri:: content://media/external/images/media/1028
     */
    private static String getRealPathFromUri_Api11To18(Context context, Uri uri) {
        String filePath = null;
        String[] projection = { MediaStore.Images.Media.DATA };

        CursorLoader loader = new CursorLoader(context, uri, projection, null,
                null, null);
        Cursor cursor = loader.loadInBackground();

        if (cursor != null) {
            cursor.moveToFirst();
            filePath = cursor.getString(cursor.getColumnIndex(projection[0]));
            cursor.close();
        }
        return filePath;
    }

    /**
     * 适配api11以下(不包括api11),根据uri获取图片的绝对路径
     */
    private static String getRealPathFromUri_BelowApi11(Context context, Uri uri) {
        String filePath = null;
        String[] projection = { MediaStore.Images.Media.DATA };
        Cursor cursor = context.getContentResolver().query(uri, projection,
                null, null, null);
        if (cursor != null) {
            cursor.moveToFirst();
            filePath = cursor.getString(cursor.getColumnIndex(projection[0]));
            cursor.close();
        }
        return filePath;
    }


    private int[][][] colorToGray2D(Bitmap myBitmap) {
        //myimage[0][][]为透明度
        //myimage[1][][]为灰度
        int width = myBitmap.getWidth();
        int height = myBitmap.getHeight();
        int[][][] myimage = new int[2][width][height];  //存储透明度和灰度图像
        int color;
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                color = myBitmap.getPixel(i,j);
                myimage[0][i][j] = Color.alpha(color);
                myimage[1][i][j] = (Color.red(color) * 299 + Color.green(color) * 587 + Color.blue(color) * 114 + 500) / 1000;
            }
        }
        return myimage;
    }

    //OTSU二值化
    public int[][] myOTSU(int[][] grayimage, int width, int height, int grayscale) {
        int[] pixelCount = new int[grayscale];
        float[] pixelPro = new float[grayscale];
        int i, j, pixelSum = width * height, threshold = 0;
        float w0, w1, u0tmp, u1tmp, u0, u1, deltaTmp, deltaMax = 0;

        //统计每个灰度级中像素的个数
        for(i = 0; i < width; i++) {
            for(j = 0;j < height;j++) {
                pixelCount[grayimage[i][j]]++;
            }
        }

        //计算每个灰度级的像素数目占整幅图像的比例
        for(i = 0; i < grayscale; i++) {
            pixelPro[i] = (float)pixelCount[i] / pixelSum;
        }

        //遍历所有从0到255灰度级的阈值分割条件，测试哪一个的类间方差最大
        for(i = 0; i < grayscale; i++) {
            w0 = w1 = u0tmp = u1tmp = u0 = u1 = deltaTmp = 0;
            for(j = 0; j < grayscale; j++) {
                if(j <= i) {  //背景部分
                    w0 += pixelPro[j];
                    u0tmp += j * pixelPro[j];
                } else {  //前景部分
                    w1 += pixelPro[j];
                    u1tmp += j * pixelPro[j];
                }
            }
            u0 = u0tmp / w0;
            u1 = u1tmp / w1;
            deltaTmp = (float)(w0 *w1* Math.pow((u0 - u1), 2)) ;
            if(deltaTmp > deltaMax) {
                deltaMax = deltaTmp;
                threshold = i;
            }
        }

        //根据threshold对图像进行二值化
        for(i = 0; i < width; i++) {
            for(j = 0; j < height; j++) {
                if (grayimage[i][j] < threshold) {
                    grayimage[i][j] = 0;  //忘记哪个是零哪个是一
                } else {
                    grayimage[i][j] = grayscale - 1;
                }
            }
        }

        return grayimage;

    }

    //二值图腐蚀运算
    //structelement形如
    // {{0,1,0},
    //  {1,1,1},
    //  {0,1,0}}
    private int[][] myerode(int[][] binaryimage, int[][] structelement, int grayscale) {
        int width = binaryimage.length;
        int height = binaryimage[0].length;
        int sewidth = structelement.length;
        int seheight = structelement[0].length;
        int[][] newbinaryimage = new int[width][height];
        //newbinaryimage = binaryimage;//浅拷贝

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                newbinaryimage[i][j] = binaryimage[i][j];
            }
        }



        for (int i = sewidth / 2; i < width - sewidth / 2; i++) {
            for (int j = seheight / 2; j < height - seheight / 2; j++) {
                //结构单元运算
                if (binaryimage[i][j] == 0) {  //当前像素为黑色
                    int temp = 0;
                    for (int a = 0; a < sewidth; a++) {
                        for (int b = 0; b < seheight; b++) {
                            if (structelement[a][b] ==0) {
                                continue;
                            }
                            temp += binaryimage[i - sewidth / 2 + a][j -seheight / 2 + b];
                        }
                        if (temp / (grayscale - 1) > 0) {
                            newbinaryimage[i][j] = grayscale - 1;
                        }
                    }
                }
            }
        }

        return newbinaryimage;

    }

    //二值图膨胀运算
    private int[][] mydilate(int[][] binaryimage, int[][] structelement, int grayscale) {
        int width = binaryimage.length;
        int height = binaryimage[0].length;
        int sewidth = structelement.length;
        int seheight = structelement[0].length;
        int[][] newbinaryimage = new int[width][height];
        //newbinaryimage = binaryimage;//浅拷贝

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                newbinaryimage[i][j] = binaryimage[i][j];
            }
        }

        //结构元非零元素个数
        int senum = 0;
        for (int i = 0; i < sewidth; i++) {
            for (int j = 0; j < seheight; j++) {
                if (structelement[i][j] != 0) {
                    senum++;
                }
            }
        }

        for (int i = sewidth / 2; i < width - sewidth / 2; i++) {
            for (int j = seheight / 2; j < height - seheight / 2; j++) {
                //结构单元运算
                if (binaryimage[i][j] == (grayscale - 1)) {  //当前像素为白色
                    int temp = 0;
                    for (int a = 0; a < sewidth; a++) {
                        for (int b = 0; b < seheight; b++) {
                            if (structelement[a][b] == 0) {
                                continue;
                            }
                            if (binaryimage[i - sewidth / 2 + a][j - seheight / 2 + b] == 0) {
                                temp++;
                            }
                        }

                    }
                    System.out.println(temp);
                    if (temp > 0) {
                        newbinaryimage[i][j] = 0;
                    }
                }
            }
        }

        return newbinaryimage;

    }


    //灰度图转Bitmap
    @RequiresApi(api = Build.VERSION_CODES.KITKAT)
    private Bitmap gray2DToBitmap(int[][][] myimage, int width, int height) {
        Bitmap myBitmap = Bitmap.createBitmap( width, height, Bitmap.Config.ARGB_8888 );
        int color;
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                color = Color.argb(myimage[0][i][j], myimage[1][i][j], myimage[1][i][j], myimage[1][i][j]);
                myBitmap.setPixel(i, j, color);
            }
        }
        return myBitmap;
    }


    public static Context getContext() {
        return context;
    }


    //opengl中的显示区域
    class MyGLSurfaceView extends GLSurfaceView {
        private float X, Y;
        private double dis_start;
        private float dis_x_start;
        private float dis_y_start;
        private boolean isZooming;
        private boolean isZoomingNotStop;
        private float x1_start;
        private float x0_start;
        private float y1_start;
        private float y0_start;


        public MyGLSurfaceView(Context context) {
            super(context);

            ActivityManager am = (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
            ConfigurationInfo info = am.getDeviceConfigurationInfo();
            String v = info.getGlEsVersion(); //判断是否为3.0 ，一般4.4就开始支持3.0版本了。

            Log.v("MainActivity", "GLES-version: " + v);

            //设置一下opengl版本；
            setEGLContextClientVersion(3);


            setRenderer(myrenderer);


            //调用 onPause 的时候保存EGLContext
            setPreserveEGLContextOnPause(true);

            //当发生交互时重新执行渲染， 需要配合requestRender();
            setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
//            setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);

        }


        //触摸屏幕的事件
        @RequiresApi(api = Build.VERSION_CODES.N)
        @SuppressLint("ClickableViewAccessibility")
        public boolean onTouchEvent(MotionEvent motionEvent) {

            //ACTION_DOWN不return true，就无触发后面的各个事件
            if (motionEvent != null) {
                final float normalizedX = toOpenGLCoord(this, motionEvent.getX(), true);
                final float normalizedY = toOpenGLCoord(this, motionEvent.getY(), false);

                switch (motionEvent.getActionMasked()) {


                    case MotionEvent.ACTION_DOWN:
                        X=normalizedX;
                        Y=normalizedY;
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN:
                        isZooming=true;
                        isZoomingNotStop = true;
                        float x1=toOpenGLCoord(this,motionEvent.getX(1),true);
                        float y1=toOpenGLCoord(this,motionEvent.getY(1),false);
                        dis_start=computeDis(normalizedX,x1,normalizedY,y1);

/*
                        dis_x_start = x1 - normalizedX;
                        dis_y_start = y1 - normalizedY;

                        x0_start = normalizedX;
                        y0_start = normalizedY;
                        x1_start = x1;
                        y1_start = y1;
*/

                        break;
                    case MotionEvent.ACTION_MOVE:
                        if(isZooming && isZoomingNotStop){
                            float x2=toOpenGLCoord(this,motionEvent.getX(1),true);
                            float y2=toOpenGLCoord(this,motionEvent.getY(1),false);
                            double dis=computeDis(normalizedX,x2,normalizedY,y2);
                            double scale=dis/dis_start;
                            myrenderer.zoom((float) scale);

/*
                            float dis_x = x2 - normalizedX;
                            float dis_y = y2 - normalizedY;
                            float ave_x = (x2 - x1_start + normalizedX - x0_start) / 2;
                            float ave_y = (y2 - y1_start + normalizedY - y0_start) / 2;
                            myrenderer.rotate(ave_x, ave_y, (float)(computeDis((x2 + normalizedX) / 2, (x1_start + x0_start) / 2, (y2 + normalizedY) / 2, (y1_start + y0_start) / 2)));
*/

                            requestRender();
                            dis_start=dis;
                        }else if (!isZooming && ifDraw3D) {
                            myrenderer.rotate(normalizedX - X, normalizedY - Y);
                            requestRender();
                            X = normalizedX;
                            Y = normalizedY;
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        isZoomingNotStop = false;
                        X = normalizedX;
                        Y = normalizedY;
                        break;
                    case MotionEvent.ACTION_UP:
                        try{
                            if (!isZooming) {
                                if (ifPoint) {
                                    Log.v("actionUp", "Pointinggggggggggg");
//                                    System.out.println(myrenderer.getMarkerList().size());
//                                    System.out.println(myrenderer.getMarkerNum());
//                                    System.out.println("***---***");
//                                    Log.v("actionUping", "Pointinggggggggggg");
                                    if (isFinished1 || isFinished2) {
                                        if (myrenderer.getMarkerList().size() < myrenderer.getMarkerNum()) {
                                            myrenderer.setIsAddPoint(true);
                                            myrenderer.add2DMarker(normalizedX, normalizedY);
                                        } else {
                                            //clearSelect_points();
                                            Toast.makeText(getContext(), "Point num is enough!", Toast.LENGTH_SHORT).show();
                                        }
                                    } else {
                                        myrenderer.setIsAddPoint(true);
                                        myrenderer.add2DMarker(normalizedX, normalizedY);
                                    }

/*                                   if (myrenderer.getFileType() == MyRenderer.FileType.JPG || myrenderer.getFileType() == MyRenderer.FileType.PNG) {
//                                        System.out.println(myrenderer.getMarkerList().size());
//                                        System.out.println(myrenderer.getMarkerNum());
//                                        System.out.println("***---***");
                                        Log.v("actionUping", "Pointinggggggggggg");
                                        myrenderer.add2DMarker(normalizedX, normalizedY);
//                                        if (myrenderer.getMarkerList().size() < myrenderer.getMarkerNum()) {
//
//                                        } else {
//                                            ifPoint = !ifPoint;
//                                            Toast.makeText(getContext(), "Point num is enough!", Toast.LENGTH_SHORT).show();
//                                        }
                                    } else {
                                        Log.v("actionUping", "Pointinggggggggggg");
                                        myrenderer.setMarkerDrawed(normalizedX, normalizedY);
                                    }
                                    */
                                    Log.v("actionPointerDown", "(" + X + "," + Y + ")");
                                    if (isP1) {
                                        MarkerList1 = myrenderer.getMarkerList();
                                    } else {
                                        MarkerList2 = myrenderer.getMarkerList();
                                    }
                                    requestRender();

                                }

                                if (ifDelete) {
                                    Log.v("actionUp", "Deleting point!!!");
                                    myrenderer.setIsAddPoint(false);
                                    if (!ifDeletePointPair) {
                                        myrenderer.delete2DMarker(normalizedX, normalizedY);
                                        Log.v("actionPointerDown", "(" + X + "," + Y + ")");
                                        if (isP1) {
                                            MarkerList1 = myrenderer.getMarkerList();
                                        } else {
                                            MarkerList2 = myrenderer.getMarkerList();
                                        }
                                    } else {
                                        int index = myrenderer.delete2DMarkerPairs(normalizedX, normalizedY);
                                        if (isP1) {
                                            MarkerList1 = myrenderer.getMarkerList();
                                            MarkerList2.remove(index);
                                        } else {
                                            MarkerList1.remove(index);
                                            MarkerList2 = myrenderer.getMarkerList();
                                        }
                                    }


                                    requestRender();
                                }
                            }
                            isZooming = false;
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                        break;
                    default:
                        break;

                }
                return true;
            }
            return false;
        }


        //坐标系变换
        private float toOpenGLCoord(View view, float value, boolean isWidth) {
            if (isWidth) {
                return (value / (float) view.getWidth()) * 2 - 1;
            } else {
                return -((value / (float) view.getHeight()) * 2 - 1);
            }
        }


        //距离计算
        private double computeDis(float x1, float x2, float y1, float y2) {
            return sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2));
        }
    }

    @Override
    protected void onDestroy() {
        // TODO Auto-generated method stub
        super.onDestroy();
        Log.d("Mainactivity","界面被销毁了");
    }


}
